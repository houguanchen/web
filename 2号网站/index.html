<!DOCTYPE html>
<html lang="zh-CN" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>侯冠辰强化学习锅炉优化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* Define CSS variables for theming */
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-muted: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --border-color: #e2e8f0;
            --accent-color: #4f46e5;
            --accent-text: #ffffff;
            --card-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.07), 0 2px 4px -2px rgb(0 0 0 / 0.07);
            --card-shadow-hover: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        .dark {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-muted: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --accent-color: #6366f1;
            --accent-text: #ffffff;
            --card-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --card-shadow-hover: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -4px rgb(0 0 0 / 0.2);
        }

        body { 
            font-family: 'Noto Sans SC', sans-serif; 
            background-color: var(--bg-primary); 
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* Animations */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .content-section { display: none; }
        .content-section.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        
        .landing-title { animation: fadeInUp 0.8s ease-out both; }
        .landing-p { animation: fadeInUp 0.8s ease-out 0.2s both; }
        .landing-btn { animation: fadeInUp 0.8s ease-out 0.4s both; }
        .landing-logo { animation: fadeInUp 0.8s ease-out 0.6s both; }

        /* Navigation */
        .nav-link { transition: all 0.2s ease-in-out; border-left: 4px solid transparent; color: var(--text-secondary); }
        .nav-link.active { background-color: rgba(79, 70, 229, 0.1); color: var(--accent-color); border-left-color: var(--accent-color); font-weight: 600; }
        .nav-link:not(.active):hover { background-color: var(--bg-muted); transform: translateX(2px); }
        .nav-header { font-size: 0.75rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; padding: 0.75rem 1rem; margin-top: 0.5rem; }
        
        /* Components with Theme Variables */
        .card { background-color: var(--bg-secondary); border-radius: 0.75rem; box-shadow: var(--card-shadow); transition: all 0.3s ease-in-out; border: 1px solid var(--border-color); }
        .card:hover { transform: translateY(-4px); box-shadow: var(--card-shadow-hover); }
        
        h2 { border-bottom: 2px solid var(--border-color); color: var(--text-primary); }
        h3 { color: var(--text-primary); }
        
        .bg-themed-secondary { background-color: var(--bg-secondary); }
        .border-themed { border-color: var(--border-color); }
        .bg-themed-muted { background-color: var(--bg-muted); }
        .text-themed-primary { color: var(--text-primary); }
        .text-themed-secondary { color: var(--text-secondary); }

        /* Shared Flame Styles */
        .flame-visual { position: absolute; bottom: 0; left: 50%; transform-origin: bottom center; width: 60%; margin-left: -30%; background: linear-gradient(to top, #ffde00, #ff8c00, rgba(255,140,0,0)); border-radius: 50% 50% 10% 10% / 100% 100% 20% 20%; transition: all 0.4s ease-in-out; animation: flicker-animation 0.3s infinite alternate; }
        #boiler-visual-container, #boiler-visual-container-ch7 { box-shadow: inset 0 0 15px rgba(0,0,0,0.5); border: 3px solid #475569; }
        @keyframes flicker-animation { 0% { transform: scaleY(1) skewX(0deg); opacity: 0.9; } 50% { transform: scaleY(0.98) skewX(2deg); opacity: 1; } 100% { transform: scaleY(1.02) skewX(-2deg); opacity: 0.95; } }

        .deployment-step { transition: all 0.3s ease; border-left-width: 4px; border-color: transparent; }
        .deployment-step.active { border-color: var(--accent-color); background-color: rgba(79, 70, 229, 0.1); }
        
        /* Code block style */
        pre { background-color: var(--bg-muted); padding: 1rem; border-radius: 0.5rem; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.9em; color: var(--text-primary); }
        code { font-family: 'Courier New', Courier, monospace; }

        /* CMDP Lab Specific styles */
        .preview-component.hidden { display: none; }
        .preview-component.reward-highlight { background-color: rgba(34, 197, 94, 0.1); border-left: 4px solid #22c55e; padding-left: 8px;}
        .preview-component.cost-highlight { background-color: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; padding-left: 8px; }

        /* Slider styles */
        .slider::-webkit-slider-thumb { background: var(--accent-color); box-shadow: 0 0 0 3px var(--bg-secondary), 0 0 0 4px var(--accent-color); }
        .slider::-moz-range-thumb { background: var(--accent-color); }

        /* Modal styles */
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 50; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal-backdrop.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--bg-secondary); padding: 2rem; border-radius: 0.75rem; max-width: 90%; width: 500px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-backdrop.visible .modal-content { transform: scale(1); }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <section id="home-landing" class="min-h-screen flex flex-col justify-center items-center bg-gradient-to-br from-indigo-50 to-white dark:from-slate-900 dark:to-slate-800 p-4">
        <div class="max-w-3xl text-center">
            <h1 class="text-5xl md:text-6xl font-extrabold text-indigo-700 dark:text-indigo-400 mb-6 landing-title">智能锅炉优化平台</h1>
            <p class="text-lg text-slate-600 dark:text-slate-300 mb-8 max-w-2xl mx-auto landing-p">融合强化学习与工业机理，驱动锅炉节能减排新纪元。<br>为电厂智能化升级提供一站式解决方案。</p>
            <button id="start-experience-btn" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-indigo-700 hover:shadow-xl transform hover:-translate-y-1 transition-all text-xl landing-btn">
                <i class="fa-solid fa-rocket mr-2"></i>立即体验
            </button>
            <div class="mt-12 flex justify-center gap-8 items-center landing-logo">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Southeast_University_logo.svg/1200px-Southeast_University_logo.svg.png" alt="东南大学" class="h-16 rounded-full bg-white border-2 border-yellow-500 p-1" onerror="this.onerror=null;this.src='https://placehold.co/64x64/facc15/ffffff?text=SEU';" />
            </div>
        </div>
        <footer class="text-center text-slate-500 dark:text-slate-400 text-sm py-6 w-full absolute bottom-0 border-t border-slate-200 dark:border-slate-700">
            &copy; 2025 智能锅炉优化平台 | 技术支持：HGC | 
            <i class="fa-solid fa-eye"></i> 访问量: <span id="visitor-count">加载中...</span>
        </footer>
    </section>

    <!-- Main App Interface -->
    <div id="main-app" class="hidden">
        <div class="flex flex-col md:flex-row min-h-screen">
            <!-- Sidebar -->
            <aside class="w-full md:w-80 bg-themed-secondary border-r border-themed flex-shrink-0 flex flex-col">
                <div class="p-4 border-b border-themed">
                    <div class="flex items-center gap-3 cursor-pointer" id="main-logo">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Southeast_University_logo.svg/1200px-Southeast_University_logo.svg.png" alt="东南大学" class="h-10 w-10 rounded-full bg-white p-0.5" onerror="this.onerror=null;this.src='https://placehold.co/40x40/facc15/ffffff?text=SEU';" />
                        <div>
                            <h1 class="text-xl font-bold text-indigo-500 dark:text-indigo-400">RL锅炉优化</h1>
                            <p class="text-xs text-themed-secondary mt-1">HGC学习与实验平台</p>
                        </div>
                    </div>
                </div>
                <nav id="main-nav" class="p-2 space-y-1 overflow-y-auto flex-grow">
                    <div class="nav-header">第一部分：基础篇</div>
                    <a href="#chapter1" data-view="chapter1" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-book-open w-5 text-center mr-3"></i> 第1章: 锅炉系统原理</a>
                    <a href="#chapter2" data-view="chapter2" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-globe w-5 text-center mr-3"></i> 第2章: 强化学习世界观</a>
                    
                    <div class="nav-header">第二部分：核心算法</div>
                    <a href="#chapter3" data-view="chapter3" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-brain w-5 text-center mr-3"></i> 第3章: 从RL到深度RL</a>
                    <a href="#chapter4" data-view="chapter4" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-masks-theater w-5 text-center mr-3"></i> 第4章: 演员-评论家架构</a>
                    <a href="#chapter5" data-view="chapter5" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-lock w-5 text-center mr-3"></i> 第5章: PPO算法详解</a>
                    <a href="#chapter6" data-view="chapter6" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-compass w-5 text-center mr-3"></i> 第6章: SAC算法详解</a>

                    <div class="nav-header">第三部分：实践篇</div>
                    <a href="#chapter7" data-view="chapter7" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-ruler-combined w-5 text-center mr-3"></i> 第7章: CMDP构建实验室</a>
                    <a href="#chapter8" data-view="chapter8" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-robot w-5 text-center mr-3"></i> 第8章: 构建数字孪生</a>
                    <a href="#chapter9" data-view="chapter9" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-flask-vial w-5 text-center mr-3"></i> 第9章: 训练实验与调试</a>

                    <div class="nav-header">第四部分：部署篇</div>
                    <a href="#chapter10" data-view="chapter10" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-ship w-5 text-center mr-3"></i> 第10章: 三阶段安全部署</a>
                    <a href="#chapter11" data-view="chapter11" class="nav-link flex items-center p-3 rounded-lg font-medium"><i class="fa-solid fa-flag-checkered w-5 text-center mr-3"></i> 第11章: 总结与未来</a>
                </nav>
                <div class="p-4 border-t border-themed">
                     <div id="user-info-panel" class="p-2 bg-themed-muted rounded-lg text-xs text-themed-secondary cursor-pointer hover:bg-opacity-80 transition">
                        <div class="flex items-center gap-2">
                           <i class="fa-solid fa-user-check text-green-500"></i>
                           <div>
                               <strong>当前用户:</strong>
                               <span id="user-id-display" class="font-mono block truncate">未登录</span>
                           </div>
                        </div>
                    </div>
                    <div class="mt-2 text-xs text-themed-secondary space-y-2">
                        <button id="contact-btn" class="w-full text-left p-2 rounded-md hover:bg-themed-muted transition flex items-center gap-2"><i class="fa-solid fa-envelope w-4"></i> 联系我们</button>
                        <button id="theme-toggle-btn" class="w-full text-left p-2 rounded-md hover:bg-themed-muted transition flex items-center gap-2">
                            <i id="theme-icon" class="fa-solid fa-moon w-4"></i>
                            <span id="theme-text">切换深色模式</span>
                        </button>
                    </div>
                </div>
            </aside>

            <!-- Main Content Area -->
            <main class="flex-1 p-4 md:p-8 bg-themed-primary overflow-y-auto">
                <!-- Chapter content will be injected here -->
                <section id="chapter1" class="content-section"></section>
                <section id="chapter2" class="content-section"></section>
                <section id="chapter3" class="content-section"></section>
                <section id="chapter4" class="content-section"></section>
                <section id="chapter5" class="content-section"></section>
                <section id="chapter6" class="content-section"></section>
                <section id="chapter7" class="content-section"></section>
                <section id="chapter8" class="content-section"></section>
                <section id="chapter9" class="content-section"></section>
                <section id="chapter10" class="content-section"></section>
                <section id="chapter11" class="content-section"></section>
            </main>
        </div>
    </div>

    <!-- Modals -->
    <div id="user-modal" class="modal-backdrop">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-indigo-500 dark:text-indigo-400 mb-4">您的专属用户凭证</h3>
            <p class="text-themed-secondary mb-4">您好！系统已为您分配了一个唯一的匿名用户ID。这个ID可以帮助我们在未来为您保存学习进度或实验配置。</p>
            <div class="p-3 bg-themed-muted rounded-lg text-center font-mono break-all" id="modal-user-id"></div>
            <button id="close-user-modal-btn" class="mt-6 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">关闭</button>
        </div>
    </div>
    <div id="contact-modal" class="modal-backdrop">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-indigo-500 dark:text-indigo-400 mb-4">联系我们 / 反馈</h3>
            <p id="contact-intro" class="text-themed-secondary mb-6">我们非常欢迎您的建议和反馈，这将帮助我们不断改进平台。</p>
            <div id="contact-success-msg" class="hidden p-4 mb-4 text-sm text-green-700 bg-green-100 rounded-lg dark:bg-green-200 dark:text-green-800" role="alert">
                <span class="font-medium">发送成功!</span> 感谢您的反馈。
            </div>
            <form id="contact-form">
                <div class="space-y-4">
                    <div>
                        <label for="contact-name" class="block text-sm font-medium text-themed-secondary">姓名</label>
                        <input type="text" id="contact-name" class="mt-1 block w-full bg-themed-muted border border-themed rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="contact-email" class="block text-sm font-medium text-themed-secondary">邮箱</label>
                        <input type="email" id="contact-email" class="mt-1 block w-full bg-themed-muted border border-themed rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="contact-message" class="block text-sm font-medium text-themed-secondary">内容</label>
                        <textarea id="contact-message" rows="4" class="mt-1 block w-full bg-themed-muted border border-themed rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                    </div>
                </div>
                <div class="mt-6 flex justify-end gap-3">
                    <button type="button" id="close-contact-modal-btn" class="bg-themed-muted text-themed-primary font-bold py-2 px-4 rounded-lg hover:bg-opacity-80 transition-colors">取消</button>
                    <button type="submit" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">提交</button>
                </div>
            </form>
        </div>
    </div>


    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration and Initialization ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'rl-boiler-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, auth, db;

        if (firebaseConfig) {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                console.log("Firebase initialized successfully.");
                setupAuthListener();
                incrementAndShowVisitorCount();
            } catch (e) {
                console.error("Firebase initialization failed:", e);
                displayFirebaseError();
            }
        } else {
            console.warn("Firebase config not found. Features like visitor count and user ID will be disabled.");
            displayFirebaseError();
        }

        // --- Authentication ---
        function setupAuthListener() {
            onAuthStateChanged(auth, user => {
                const userIdDisplay = document.getElementById('user-id-display');
                if (user) {
                    userIdDisplay.textContent = user.uid;
                    document.getElementById('modal-user-id').textContent = user.uid;
                } else {
                    signIn();
                }
            });
        }

        async function signIn() {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Error signing in:", error);
                document.getElementById('user-id-display').textContent = "登录失败";
            }
        }

        // --- Visitor Counter ---
        async function incrementAndShowVisitorCount() {
            if (!db) return;
            const visitorCountEl = document.getElementById('visitor-count');
            const counterRef = doc(db, `artifacts/${appId}/public/data/analytics`, 'page_views');

            try {
                await runTransaction(db, async (transaction) => {
                    const counterDoc = await transaction.get(counterRef);
                    const newCount = counterDoc.exists() ? counterDoc.data().count + 1 : 1;
                    transaction.set(counterRef, { count: newCount }, { merge: true });
                });
                const finalDoc = await getDoc(counterRef);
                if (finalDoc.exists()) {
                    visitorCountEl.textContent = finalDoc.data().count;
                }
            } catch (e) {
                console.error("Failed to update visitor count:", e);
                visitorCountEl.textContent = 'N/A';
            }
        }

        function displayFirebaseError() {
            document.getElementById('visitor-count').textContent = '服务不可用';
            document.getElementById('user-id-display').textContent = '服务不可用';
        }

        // --- Main Application Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- Chapter Content Injection ---
            const chapterContents = {
                chapter1: `
                    <h2>第1章: 锅炉系统原理</h2>
                    <p class="text-lg text-themed-secondary mb-6">在应用任何高级算法之前，必须对被控对象——锅炉，有深刻的物理和工程理解。本章将带您深入了解锅炉背后的核心矛盾，并通过一个进化版的互动沙箱，让您亲手感受在动态工况下控制锅炉的挑战。</p>
                    <div class="card p-6 mb-6">
                        <h3 class="text-xl font-bold">系统组件与热力循环</h3>
                        <p class="text-themed-secondary mb-4">锅炉并非孤立设备，而是发电厂热力系统的核心。它通过燃烧燃料（如煤粉）产生高温高压蒸汽，驱动汽轮机做功发电。这个过程在热力学上遵循经典的**朗肯循环**。理解这一循环有助于我们明确锅炉在整个发电流程中的角色：它是一个能量转换器，将燃料的化学能高效地转化为蒸汽的热能。</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                            <div id="boiler-diagram-container" class="p-2 bg-themed-secondary rounded-lg shadow-inner"></div>
                            <div id="rankine-diagram-container" class="p-2 bg-themed-secondary rounded-lg shadow-inner"></div>
                        </div>
                        <p class="text-sm text-themed-secondary mt-2 text-center">左：典型煤粉锅炉系统示意图。右：理想朗肯循环T-s图。</p>
                    </div>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold">动态工况锅炉沙箱</h3>
                        <p class="text-themed-secondary mb-6">我们引入了"锅炉负荷"作为关键的外部扰动。负荷代表了电网对发电机组的电力需求。您的任务是在不同负荷下，通过调节控制变量（动作），使各项指标（状态）尽可能接近目标值，体验多目标优化的核心挑战。</p>
                        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                            <div class="lg:col-span-2 bg-themed-muted p-6 rounded-lg">
                                <h4 class="font-bold text-lg mb-4">🕹️ 控制与工况面板</h4>
                                <div class="space-y-6">
                                    <div>
                                        <label for="load-slider" class="font-medium flex justify-between">锅炉负荷 (扰动): <span id="load-value" class="font-bold text-red-500">75</span>%</label>
                                        <input type="range" id="load-slider" min="50" max="100" value="75" class="slider w-full">
                                    </div>
                                    <div class="border-t border-themed pt-4">
                                        <label for="air-total-slider" class="font-medium flex justify-between">总风量 (动作): <span id="air-total-value">75</span>%</label>
                                        <input type="range" id="air-total-slider" min="50" max="100" value="75" class="slider w-full">
                                    </div>
                                    <div>
                                        <label for="burner-tilt-slider" class="font-medium flex justify-between">燃烧器摆角 (动作): <span id="burner-tilt-value">0</span>°</label>
                                        <input type="range" id="burner-tilt-slider" min="-15" max="15" value="0" class="slider w-full">
                                    </div>
                                    <div>
                                        <label for="o2-dist-slider" class="font-medium flex justify-between">燃尽风(OFA)占比 (动作): <span id="o2-dist-value">30</span>%</label>
                                        <input type="range" id="o2-dist-slider" min="10" max="50" value="30" class="slider w-full">
                                    </div>
                                </div>
                            </div>
                            <div class="lg:col-span-3">
                                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                     <div class="p-4 rounded-lg bg-slate-700 flex flex-col items-center justify-center min-h-[300px]">
                                         <h4 class="font-bold text-lg mb-2 text-white">🔥 炉膛火焰</h4>
                                         <div id="boiler-visual-container" class="w-48 h-64 bg-slate-800 rounded-t-lg relative overflow-hidden"><div id="flame-visual" class="flame-visual"></div></div>
                                     </div>
                                     <div class="p-4 rounded-lg bg-themed-muted flex flex-col justify-between">
                                         <h4 class="font-bold text-lg mb-4">📈 关键指标</h4>
                                         <div class="space-y-4">
                                             <div>
                                                 <label class="font-medium flex justify-between">氮氧化物 (NOx) <span class="text-sm text-themed-secondary">目标: &lt;50</span></label>
                                                 <div class="w-full bg-slate-200 dark:bg-slate-600 rounded-full h-4"><div id="nox-meter-fill" class="bg-red-500 h-4 rounded-full transition-all duration-300"></div></div>
                                             </div>
                                             <div>
                                                 <label class="font-medium flex justify-between">一氧化碳 (CO) <span class="text-sm text-themed-secondary">目标: &lt;40</span></label>
                                                 <div class="w-full bg-slate-200 dark:bg-slate-600 rounded-full h-4"><div id="co-meter-fill" class="bg-amber-500 h-4 rounded-full transition-all duration-300"></div></div>
                                             </div>
                                             <div>
                                                 <label class="font-medium flex justify-between">锅炉热效率 <span class="text-sm text-themed-secondary">目标: &gt;93%</span></label>
                                                 <div class="text-right"><span id="efficiency-value" class="text-2xl font-bold text-green-600">92.50</span> %</div>
                                             </div>
                                         </div>
                                     </div>
                                 </div>
                            </div>
                        </div>
                    </div>
                    <div class="card p-6 mt-6">
                        <h3 class="text-xl font-bold">核心矛盾：帕累托最优前沿</h3>
                        <p class="text-themed-secondary mb-6">锅炉优化的本质是在多个相互冲突的目标之间寻找最佳平衡点。例如，降低NOx排放可能会增加CO排放并降低热效率。这个最佳平衡点的集合被称为"帕累托最优前沿"。RL智能体的任务，就是在不同工况下，找到并维持在这一前沿上的最优工作点。下图展示了热效率与NOx排放的关系，请尝试调节控制变量，让"当前工作点"尽可能地接近左上方的"帕累托前沿"虚线。</p>
                        <div class="p-4 bg-themed-muted rounded-lg"><canvas id="pareto-chart" height="120"></canvas></div>
                    </div>
                `,
                chapter2: `
                    <h2>第2章: 强化学习世界观</h2>
                    <p class="text-lg text-themed-secondary mb-6">强化学习(RL)是一种通过"试错"来学习的机器学习范式。智能体(Agent)在与环境(Environment)的交互中，根据获得的奖励(Reward)或惩罚来学习如何选择动作(Action)，以最大化长期累积奖励。</p>
                     <div class="card p-6 mb-6">
                         <h3 class="text-xl font-bold">2.1 马尔可夫决策过程 (MDP)</h3>
                         <p class="text-themed-secondary mb-4">RL问题通常被数学化地描述为马尔可夫决策过程 (MDP)，一个由五元组构成的模型： $(S, A, P, R, \\gamma)$</p>
                         <ul class="list-disc list-inside space-y-2 text-themed-secondary bg-themed-muted p-4 rounded-lg">
                            <li><b>S (State)</b>: 状态集合。在锅炉问题中，这可以是 $\{主蒸汽压力, 主蒸汽温度, O_2含量, ...\}$。</li>
                            <li><b>A (Action)</b>: 动作集合。例如 $\{总风门开度, 燃烧器摆角, ...\}$。</li>
                            <li><b>P (Transition Probability)</b>: 状态转移概率 $P(s'|s,a)$。即在状态 $s$ 下执行动作 $a$ 后，转移到状态 $s'$ 的概率。</li>
                            <li><b>R (Reward Function)</b>: 奖励函数 $R(s,a,s')$。执行动作后得到的即时奖励。</li>
                            <li><b>$\\gamma$ (Discount Factor)</b>: 折扣因子，取值在 $[0, 1]$ 之间，决定了未来奖励的重要性。</li>
                         </ul>
                    </div>
                    <div class="card p-6 mb-6">
                         <h3 class="text-xl font-bold">2.2 贝尔曼方程：价值学习的核心</h3>
                         <p class="text-themed-secondary mb-4">RL的目标是找到一个最优策略 $\\pi^*(a|s)$。为了评估策略，我们定义了状态价值函数 $V^\\pi(s)$，它遵循著名的贝尔曼期望方程：</p>
                         <div class="p-4 my-2 bg-themed-muted rounded text-center text-lg">$$V^\\pi(s) = \\mathbb{E}_{\\pi} [R_{t+1} + \\gamma V^\\pi(S_{t+1}) | S_t=s]$$</div>
                         <p class="text-themed-secondary mt-4">这个公式将复杂、长期的回报问题，分解为了一个当前奖励和下一状态价值的递归关系，是所有价值学习算法的基石。</p>
                    </div>
                    <div class="card p-6 mb-6">
                           <h3 class="text-xl font-bold">2.3 RL算法全景图</h3>
                           <p class="text-themed-secondary mb-4">RL算法种类繁多，但可以根据几个关键维度进行分类。下图为您提供了一个清晰的分类框架，帮助您理解不同算法之间的关系。</p>
                           <div id="rl-taxonomy-container" class="p-4 bg-themed-muted rounded-lg flex justify-center"></div>
                </div>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold">2.4 交互式动态规划求解器</h3>
                        <p class="text-themed-secondary mb-4">动态规划(DP)是解决已知模型MDP的基础方法。虽然在现实中我们通常不知道精确模型，但理解它的工作原理是理解更高级的无模型算法的基石。下面，您可以亲手操作<b>价值迭代</b>和<b>策略迭代</b>。</p>
                        <div class="flex flex-col md:flex-row gap-6 items-center">
                            <div class="flex-shrink-0"><canvas id="bellman-canvas" width="400" height="400" class="border border-themed rounded-lg bg-themed-secondary"></canvas></div>
                            <div class="space-y-4">
                                <div class="flex gap-2">
                                    <button id="iterate-bellman-btn" class="flex-1 bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors">迭代一步 (Step)</button>
                                    <button id="reset-bellman-btn" class="bg-slate-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-600 transition-colors">重置</button>
                                </div>
                                 <div class="p-2 bg-themed-muted rounded-lg">
                                     <label for="dp-method-select" class="text-sm font-bold">选择算法:</label>
                                     <select id="dp-method-select" class="w-full p-2 rounded border-themed bg-themed-secondary"><option value="vi">价值迭代</option><option value="pi">策略迭代</option></select>
                                 </div>
                                <div class="text-sm p-4 bg-themed-muted rounded-lg">
                                    <p><strong>迭代次数:</strong> <span id="bellman-iteration-count">0</span></p>
                                    <p><strong>当前阶段:</strong> <span id="pi-phase-info">--</span></p>
                                    <p class="mt-2"><b>价值迭代:</b> 直接迭代更新价值函数，直到收敛得到最优价值。</p>
                                    <p class="mt-2"><b>策略迭代:</b> 在"策略评估"和"策略提升"两个阶段间交替进行。</p>
                                </div>
                                <div id="bellman-update-info" class="text-sm text-center font-mono h-8"></div>
                            </div>
                        </div>
                    </div>
                `,
                chapter3: `
                    <h2>第3章: 从RL到深度RL</h2>
                    <p class="text-lg text-themed-secondary mb-6">经典RL方法使用表格存储价值，但这在状态空间巨大时（维度灾难）不可行。深度学习通过使用神经网络作为强大的函数逼近器，催生了深度强化学习（DRL），彻底改变了这一领域。</p>
                     <div class="card p-6 mb-6">
                         <h3 class="text-xl font-bold">函数逼近的必要性</h3>
                         <p class="text-themed-secondary mb-4">锅炉的状态由多个连续变量描述，总状态数是天文数字。神经网络（NN）的泛化能力使其不需见过所有状态，就能学习从高维输入到期望输出的复杂映射。我们用带参数 $\\theta$ 的函数来逼近价值或策略函数：</p>
                         <ul class="list-disc list-inside space-y-2 text-themed-secondary">
                             <li><b>价值函数逼近</b>: $V(s; \\theta) \\approx V^*(s)$ 或 $Q(s, a; \\theta) \\approx Q^*(s, a)$。</li>
                             <li><b>策略函数逼近</b>: 直接学习一个带参数的策略 $\\pi(a|s; \\theta)$。</li>
                         </ul>
                     </div>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold">深度Q网络 (DQN)</h3>
                        <p class="text-themed-secondary mb-4">DQN是DRL的开创性工作，它成功地将深度学习与Q-Learning结合。DQN引入了两个关键技术来解决训练不稳定的问题，至今仍是许多现代DRL算法的基石：</p>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                             <div class="p-4 bg-blue-500/10 rounded-lg">
                                 <h4 class="font-bold text-blue-600 dark:text-blue-400">经验回放 (Experience Replay)</h4>
                                  <p class="text-sm mt-2">智能体与环境交互的经验 $(s_t, a_t, r_t, s_{t+1})$ 被存储在"回放池"中。训练时，随机采样一个小批量数据进行更新。这打破了数据相关性，并提高了数据利用效率。</p>
                             </div>
                             <div class="p-4 bg-green-500/10 rounded-lg">
                                 <h4 class="font-bold text-green-600 dark:text-green-400">目标网络 (Target Network)</h4>
                                 <p class="text-sm mt-2">使用两个网络：一个频繁更新的在线网络 $Q(s, a; \\theta)$，和一个定期从在线网络复制权重的目标网络 $Q(s', a'; \\theta')$。在计算TD目标时使用固定的目标网络，极大地增强了训练的稳定性。</p>
                                 <div class="p-2 my-2 bg-themed-muted rounded text-center text-sm">$$L(\\theta) = \\mathbb{E}_{(s,a,r,s') \\sim D} \\left[ (r + \\gamma \\max_{a'} Q(s', a'; \\theta') - Q(s, a; \\theta))^2 \\right]$$</div>
                             </div>
                         </div>
                    </div>
                `,
                chapter4: `
                    <h2>第4章: 演员-评论家架构</h2>
                    <p class="text-lg text-themed-secondary mb-6">演员-评论家（Actor-Critic, AC）方法是现代RL算法的支柱，它结合了策略学习和价值学习的优点。AC方法的核心是同时维护两个模型：</p>
                    <div class="card p-6 mb-6">
                        <h3 class="text-xl font-bold">演员与评论家的角色分工</h3>
                        <ul class="list-disc list-inside space-y-2 text-themed-secondary">
                            <li><b>演员 (Actor)</b>: 产出动作。它是一个参数化的策略 $\\pi_\\theta(a|s)$，目标是调整参数 $\\theta$ 来获得更高的分数。</li>
                            <li><b>评论家 (Critic)</b>: 评价演员的动作有多好。它是一个参数化的价值函数，如 $Q_\\phi(s,a)$ 或 $V_\\phi(s)$。</li>
                        </ul>
                        <p class="text-themed-secondary mt-4">两者协同工作：演员执行动作，评论家评价，演员根据反馈调整。这种方式比单纯的策略梯度方法方差更小，同时又能处理DQN难以处理的连续动作空间。</p>
                    </div>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold">动态演示：信息与优势函数流动过程</h3>
                        <p class="text-themed-secondary mb-4">点击播放下面的动画，观察一个典型的AC更新周期。特别注意，评论家会计算出**优势函数 $A(s,a) = Q(s,a) - V(s)$**，这个信号是指导演员更新策略的核心依据，它回答了"在状态s下，执行动作a比平均来看有多好？"这个问题。</p>
                        <div class="text-center mb-4"><button id="play-ac-viz" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">▶️ 播放流程</button></div>
                        <div id="ac-viz-explanation" class="text-center font-semibold h-10 mb-2"></div>
                        <div id="ac-diagram-container" class="flex justify-center"></div>
                    </div>
                `,
                chapter5: `
                    <h2>第5章: PPO算法详解</h2>
                    <p class="text-lg text-themed-secondary mb-6">近端策略优化（PPO）是目前应用最广泛的RL算法之一，以其卓越的稳定性和性能而闻名。其核心思想是：在更新策略时，步子不能迈得太大。它通过一个"裁剪"机制，将策略更新限制在一个可信的"信任域"内。</p>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold">交互式理解：可调节的信任域裁剪</h3>
                        <p class="text-themed-secondary mb-4">令 $r_t(\\theta) = \\frac{\\pi_\\theta(a_t|s_t)}{\\pi_{\\theta_{old}}(a_t|s_t)}$ 为新旧策略的概率比。请拖动 $\\epsilon$ 滑块来调整信任域大小，并切换"好动作"（优势 $\\hat{A}_t > 0$）和"坏动作"（$\\hat{A}_t < 0$）的情景，观察目标函数（蓝色实线）如何被裁剪边界（红色虚线）所限制。</p>
                        <div class="flex justify-center items-center gap-6 mb-4">
                            <button id="ppo-toggle-advantage" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">切换到 "坏动作"</button>
                            <div class="w-64">
                                 <label for="epsilon-slider" class="font-medium flex justify-between">裁剪范围 $\\epsilon$: <span id="epsilon-value">0.2</span></label>
                                 <input type="range" id="epsilon-slider" min="0.05" max="0.5" step="0.01" value="0.2" class="slider w-full h-2 bg-themed-muted rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>
                        <canvas id="ppo-canvas" class="w-full h-64 bg-themed-muted border border-themed rounded-lg"></canvas>
                        <p id="ppo-explanation" class="text-center mt-2 font-medium"></p>
                    </div>
                     <div class="card p-6 mt-6">
                         <h3 class="text-xl font-bold">PPO核心组件与伪代码</h3>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                             <div class="space-y-4">
                                 <div class="p-4 bg-blue-500/10 rounded-lg">
                                     <h4 class="font-bold text-blue-600 dark:text-blue-400">裁剪代理目标</h4>
                                      <p class="text-sm mt-2">这是PPO的核心创新。它在传统策略梯度目标和裁剪版本间取最小值，限制了策略更新的幅度，避免策略突变。</p>
                                      <div class="p-2 my-2 bg-themed-muted rounded text-center">$$L^{CLIP}(\\theta) = \\mathbb{E}_t \\left[ \\min\\left(r_t(\\theta)\\hat{A}_t, \\text{clip}(r_t(\\theta), 1-\\epsilon, 1+\\epsilon)\\hat{A}_t\\right) \\right]$$</div>
                                 </div>
                                 <div class="p-4 bg-green-500/10 rounded-lg">
                                     <h4 class="font-bold text-green-600 dark:text-green-400">广义优势估计 (GAE)</h4>
                                     <p class="text-sm mt-2">PPO通常采用GAE来准确估计优势函数 $\\hat{A}_t$。GAE在低偏差的TD误差和高方差的蒙特卡洛估计之间进行权衡，提供更稳定的优势信号。</p>
                                 </div>
                             </div>
                             <div>
                                 <h4 class="font-bold">PPO 伪代码</h4>
                                 <pre><code>Initialize policy and value networks
for iteration = 1, 2, ... do
  // 1. Data Collection
  Run old policy to collect trajectories
  // 2. Advantage & Return Calculation
  Compute advantages (GAE) and returns
  // 3. Optimization
  for K epochs do
    for mini_batch in trajectories do
      Update policy via clipped objective
      Update value function via MSE
    end for
  end for
  Update old policy
end for</code></pre>
                             </div>
                         </div>
                     </div>
                `,
                chapter6: `
                    <h2>第6章: SAC算法详解</h2>
                    <p class="text-lg text-themed-secondary mb-6">软演员-评论家（SAC）是一种基于最大熵强化学习框架的off-policy算法。SAC的目标是最大化奖励的同时，也最大化策略的**熵**（随机性）。这使得SAC成为一个强大的探险家，带来了极强的鲁棒性和探索效率。</p>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold">交互式理解：探索与利用的权衡</h3>
                        <p class="text-themed-secondary mb-4">SAC的目标是 $J(\\pi) = \\sum \\mathbb{E} [r(s_t, a_t) + \\alpha \\mathcal{H}(\\pi(\\cdot|s_t))]$。其中 $\\alpha$ 是"温度"参数，控制熵奖励的重要性。请调整温度参数 $\\alpha$，观察策略（蓝色区域）是如何在"探索"（高$\\alpha$）和"利用"（低$\\alpha$）之间变化的。</p>
                        <canvas id="sac-canvas" class="w-full h-64 bg-themed-muted border border-themed rounded-lg"></canvas>
                        <div class="mt-4">
                            <label for="alpha-slider" class="font-medium flex justify-between">温度 $\\alpha$: <span id="alpha-value">0.20</span></label>
                            <input type="range" id="alpha-slider" min="0.01" max="1.0" step="0.01" value="0.2" class="slider w-full h-2 bg-themed-muted rounded-lg appearance-none cursor-pointer">
                        </div>
                         <p id="sac-explanation" class="text-center mt-2 font-medium"></p>
                    </div>
                    <div class="card p-6 mt-6">
                        <h3 class="text-xl font-bold">SAC核心组件</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="p-4 bg-purple-500/10 rounded-lg">
                                <h4 class="font-bold text-purple-600 dark:text-purple-400">双Q网络 (Twin Q-Critics)</h4>
                                 <p class="text-sm mt-2">为了缓解价值函数被过高估计的问题，SAC采用两个独立的Q网络，在计算目标价值时悲观地取两个Q网络预测值的较小者，使学习过程更稳定。</p>
                            </div>
                            <div class="p-4 bg-teal-500/10 rounded-lg">
                                <h4 class="font-bold text-teal-600 dark:text-teal-400">自动熵调优</h4>
                                <p class="text-sm mt-2">手动调整 $\\alpha$ 很困难。SAC能自动调整$\\alpha$。通过设定一个目标熵，算法会学习一个合适的$\\alpha$值，使策略的实际熵动态地接近该目标，实现了探索和利用的自动平衡。</p>
                            </div>
                        </div>
                    </div>
                `,
                chapter7: `
                    <h2>第7章: CMDP构建实验室</h2>
                    <p class="text-lg text-themed-secondary mb-6">对于既要追求经济效益，又必须遵守安全红线的任务，我们引入**约束马尔可夫决策过程（CMDP）**。CMDP在标准MDP上增加了"成本函数"和约束。智能体的目标是在满足成本约束的前提下，最大化累积奖励。在这个实验室里，请您扮演AI工程师，亲手定义状态、动作、奖励和约束。</p>
                    <div class="card p-6">
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <div id="cmdp-builder-panel">
                                <h3 class="text-xl font-bold">1. 构建您的CMDP模型</h3>
                                <p class="text-themed-secondary mb-6">请勾选您希望纳入模型的变量。<b>奖励</b>是我们希望最大化的指标，而<b>成本/约束</b>是我们必须遵守的红线。</p>
                                <div class="mb-4"><h4 class="font-bold text-lg mb-2 text-indigo-500 dark:text-indigo-400">S - 选择状态</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-nox-meter"> NOx浓度</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-co-meter"> CO浓度</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-efficiency-meter"> 热效率</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-temp-meter"> 关键壁温</label></div></div>
                                <div class="mb-4"><h4 class="font-bold text-lg mb-2 text-green-600 dark:text-green-500">A - 选择动作</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-air-slider"> 总风量</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-tilt-slider"> 燃烧器摆角</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-ofa-slider"> 燃尽风占比</label></div></div>
                                <div class="mb-4"><h4 class="font-bold text-lg mb-2 text-amber-600 dark:text-amber-500">R - 定义奖励</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-efficiency-meter" data-type="reward"> 奖励：提升热效率</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-nox-meter" data-type="reward"> 奖励：降低NOx</label></div></div>
                                <div class="mb-4"><h4 class="font-bold text-lg mb-2 text-red-600 dark:text-red-500">C - 定义成本/约束</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-temp-meter" data-type="cost"> 约束：壁温</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-co-meter" data-type="cost"> 约束：CO浓度</label></div></div>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold">2. 实时预览与交互</h3>
                                <p class="text-themed-secondary mb-6">这里是您构建的虚拟锅炉。被定义为"奖励"的模块会以绿色高亮，"约束"模块以红色高亮。</p>
                                <div class="p-4 rounded-lg bg-slate-700 flex flex-col items-center justify-start min-h-[500px]">
                                    <h4 class="font-bold text-lg mb-2 text-white">🔥 虚拟锅炉实时视图</h4>
                                    <div id="boiler-visual-container-ch7" class="w-48 h-64 bg-slate-800 rounded-t-lg relative overflow-hidden mt-4"><div id="flame-visual-ch7" class="flame-visual"></div></div>
                                    <div id="dashboard-ch7" class="w-full mt-6 space-y-4 p-2">
                                        <div id="component-nox-meter" class="preview-component hidden p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">NOx</label><div class="w-full bg-slate-500 rounded-full h-3"><div id="nox-meter-fill-ch7" class="bg-red-500 h-3 rounded-full"></div></div></div>
                                        <div id="component-co-meter" class="preview-component hidden p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">CO</label><div class="w-full bg-slate-500 rounded-full h-3"><div id="co-meter-fill-ch7" class="bg-amber-500 h-3 rounded-full"></div></div></div>
                                        <div id="component-temp-meter" class="preview-component hidden p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">壁温</label><div class="w-full bg-slate-500 rounded-full h-3"><div id="temp-meter-fill-ch7" class="bg-orange-500 h-3 rounded-full"></div></div></div>
                                        <div id="component-efficiency-meter" class="preview-component hidden p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">热效率</label><div class="text-right"><span id="efficiency-value-ch7" class="text-xl font-bold text-green-400">92.50</span> %</div></div>
                                    </div>
                                </div>
                                <div id="controls-ch7" class="mt-4 p-4 bg-themed-secondary rounded-lg space-y-4 border border-themed">
                                    <div id="component-air-slider" class="preview-component hidden"><label for="air-slider-ch7" class="font-medium flex justify-between text-sm">总风量: <span id="air-value-ch7">75</span>%</label><input type="range" id="air-slider-ch7" min="50" max="100" value="75" class="slider w-full"></div>
                                    <div id="component-tilt-slider" class="preview-component hidden"><label for="tilt-slider-ch7" class="font-medium flex justify-between text-sm">摆角: <span id="tilt-value-ch7">0</span>°</label><input type="range" id="tilt-slider-ch7" min="-15" max="15" value="0" class="slider w-full"></div>
                                    <div id="component-ofa-slider" class="preview-component hidden"><label for="ofa-slider-ch7" class="font-medium flex justify-between text-sm">OFA占比: <span id="ofa-value-ch7">30</span>%</label><input type="range" id="ofa-slider-ch7" min="10" max="50" value="30" class="slider w-full"></div>
                                </div>
                            </div>
                        </div>
                        <div class="mt-8 pt-4 border-t border-themed"><h3 class="text-xl font-bold">3. 您生成的CMDP模型</h3>
                              <div id="cmdp-summary-ch7" class="text-sm grid grid-cols-2 md:grid-cols-4 gap-4 p-4 bg-indigo-500/10 rounded-lg mt-4">
                                  <div><strong>状态:</strong><ul id="summary-State-ch7" class="list-disc list-inside"></ul></div>
                                  <div><strong>动作:</strong><ul id="summary-Action-ch7" class="list-disc list-inside"></ul></div>
                                  <div><strong>奖励:</strong><ul id="summary-Reward-ch7" class="list-disc list-inside"></ul></div>
                                  <div><strong>成本:</strong><ul id="summary-Cost-ch7" class="list-disc list-inside"></ul></div>
                              </div>
                        </div>
                    </div>
                `,
                chapter8: `
                    <h2>第8章: 构建数字孪生</h2>
                    <p class="text-lg text-themed-secondary mb-6">RL需要在环境中进行海量试错，这在真实的工业设备上是不可行的。因此，构建一个高保真的仿真环境——"数字孪生"——是项目成功的先决条件，它是AI智能体安全、高效训练的"虚拟健身房"。</p>
                    <div class="card p-6 mb-6">
                        <h3 class="text-xl font-bold">什么是数字孪生？</h3>
                        <p class="text-themed-secondary">数字孪生是真实物理系统的虚拟副本，能模拟真实锅炉的动态响应。构建方法主要有两类：</p>
                         <ul class="list-disc list-inside space-y-2 text-themed-secondary">
                            <li><b>机理建模</b>：基于物理定律构建方程组。解释性强，但开发周期长。</li>
                            <li><b>数据驱动建模</b>：利用历史数据，通过机器学习方法学习输入与输出的映射关系。开发快，但泛化能力依赖数据覆盖范围。</li>
                        </ul>
                        <p class="mt-4 text-themed-secondary">实践中常采用混合建模，将机理知识与数据驱动方法相结合，以期获得最佳效果。</p>
                    </div>
                    <div class="card p-6 mb-6">
                        <h3 class="text-xl font-bold">"仿真到现实"的鸿沟 (Sim-to-Real Gap)</h3>
                        <p class="mb-4 text-themed-secondary">任何仿真都无法100%复刻现实，模型与现实的差异被称为"Sim-to-Real Gap"。缩小这个鸿沟至关重要。一种有效的技术是**领域随机化 (Domain Randomization)**：在训练时，故意给仿真环境增加各种随机性（如随机化模型参数、增加传感器噪声）。这能迫使AI学习一个对不确定性不敏感的、更为鲁棒的策略。</p>
                    </div>
                     <div class="card p-6">
                         <h3 class="text-xl font-bold">交互演示：模型质量与鲁棒性</h3>
                         <p class="text-themed-secondary mb-4">拖动滑块模拟模型与现实的匹配程度。黑色实线代表"真实世界"，蓝色虚线代表数字孪生模型的预测。可以看到，即使是高质量的模型，也永远存在差距。一个鲁棒的AI策略应能在此不确定性下依然表现良好。</p>
                         <canvas id="sim-real-canvas" class="w-full h-64 bg-themed-muted border border-themed rounded-lg"></canvas>
                         <div><label for="model-quality-slider" class="font-medium flex justify-between">模型-现实匹配度: <span id="model-quality-value">50</span>%</label><input type="range" id="model-quality-slider" min="10" max="98" step="1" value="50" class="slider w-full h-2 bg-themed-muted rounded-lg"></div>
                     </div>
                `,
                chapter9: `
                    <h2>第9章: 训练实验与调试</h2>
                    <p class="text-lg text-themed-secondary mb-8">欢迎来到RL训练实验室！我们将经典的"寻宝"例子升级为"锅炉状态空间寻优"。智能体（蓝色圆点）的目标是在简化的状态网格中，从'S'出发，尽快到达'🏆'，同时避开危险区域'☠️'。您可以通过调节超参数，观察AI学习行为和最终策略的变化。</p>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1 card p-6">
                            <h3 class="text-xl font-bold">参数调节</h3>
                            <div class="space-y-4">
                                <div><label for="gamma-slider" class="font-medium flex justify-between">远见程度 ($\\gamma$): <span id="gamma-value">0.9</span></label><input type="range" id="gamma-slider" min="0.5" max="0.99" step="0.01" value="0.9" class="slider w-full"></div>
                                <div><label for="lr-slider" class="font-medium flex justify-between">学习率 ($\\alpha_{lr}$): <span id="lr-value">0.1</span></label><input type="range" id="lr-slider" min="0.01" max="0.5" step="0.01" value="0.1" class="slider w-full"></div>
                                <div><label for="epsilon-slider-ch9" class="font-medium flex justify-between">探索率 ($\\epsilon$): <span id="epsilon-value-ch9">0.2</span></label><input type="range" id="epsilon-slider-ch9" min="0.05" max="1.0" step="0.05" value="0.2" class="slider w-full"></div>
                            </div>
                            <button id="start-sim" class="mt-6 w-full bg-indigo-600 text-white font-bold py-3 rounded-lg hover:bg-indigo-700 transition-colors">开始 / 重置训练</button>
                        </div>
                        <div class="lg:col-span-2 card p-6">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <h3 class="text-xl font-bold">状态空间 (策略可视化)</h3>
                                    <canvas id="rl-canvas" class="w-full bg-themed-muted border border-themed rounded-lg aspect-square"></canvas>
                                     <div class="flex justify-around text-xs mt-2 flex-wrap"><span class="flex items-center"><div class="w-3 h-3 rounded-full bg-blue-500 mr-1"></div>智能体</span><span class="flex items-center"><div class="w-3 h-3 rounded-full bg-green-200 mr-1"></div>目标</span><span class="flex items-center"><div class="w-3 h-3 rounded-full bg-red-200 mr-1"></div>危险</span></div>
                                </div>
                                <div>
                                    <h3 class="text-xl font-bold">学习曲线 (平均奖励)</h3>
                                    <div class="w-full h-64 border border-themed rounded-lg p-2"><canvas id="rewardChart"></canvas></div>
                                    <div class="mt-2 text-center text-sm"><p>回合: <span id="episode-counter">0</span></p><p>平均奖励: <span id="total-reward">0</span></p></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `,
                chapter10: `
                    <h2>第10章: 三阶段安全部署</h2>
                    <p class="text-lg text-themed-secondary mb-6">将AI安全地引入到现实工厂中，是一个比算法本身更具挑战性的工程问题。我们必须采用一套循序渐进的策略，其核心是建立信任、管理风险，确保万无一失。</p>
                    <div class="flex flex-col lg:flex-row gap-6">
                        <div class="w-full lg:w-1/3 space-y-2">
                            <div id="step1" class="p-4 rounded-lg cursor-pointer deployment-step" onclick="selectStep(1)"><h4 class="font-bold text-lg">阶段一：建议模式</h4><p class="text-sm">AI作为"影子顾问"，零风险验证性能。</p></div>
                            <div id="step2" class="p-4 rounded-lg cursor-pointer deployment-step" onclick="selectStep(2)"><h4 class="font-bold text-lg">阶段二：监督控制</h4><p class="text-sm">AI调整PID设定值，利用现有系统作为安全网。</p></div>
                            <div id="step3" class="p-4 rounded-lg cursor-pointer deployment-step" onclick="selectStep(3)"><h4 class="font-bold text-lg">阶段三：直接控制</h4><p class="text-sm">AI直接输出指令，但须通过"安全层"过滤。</p></div>
                        </div>
                        <div id="step-content" class="flex-1 card p-6 min-h-[300px]"></div>
                    </div>
                `,
                chapter11: `
                    <h2>第11章: 总结与未来</h2>
                    <p class="text-lg text-themed-secondary mb-6">我们从锅炉原理出发，探讨了如何将工业问题抽象为CMDP模型，介绍了PPO和SAC等算法，并阐述了从数字孪生到三阶段安全部署的完整工程实践框架。成功的工业AI应用，是**算法、领域知识和工程实践**三者深度融合的产物。</p>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold">未来研究方向</h3>
                        <p class="text-themed-secondary mb-6">锅炉优化领域仍有广阔的探索空间：</p>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                            <div class="p-4 bg-themed-muted rounded-lg hover:shadow-md transition">
                                <h4 class="font-bold text-lg">多智能体 (MARL)</h4>
                                <p class="text-sm mt-2">将每个燃烧器视为一个独立的智能体，学习协同配合，以实现比单智能体更精细的控制。</p>
                            </div>
                            <div class="p-4 bg-themed-muted rounded-lg hover:shadow-md transition">
                                <h4 class="font-bold text-lg">可解释性 (XAI)</h4>
                                <p class="text-sm mt-2">让AI不再是"黑箱"，能够解释其决策原因，对于建立操作员信任至关重要。</p>
                            </div>
                            <div class="p-4 bg-themed-muted rounded-lg hover:shadow-md transition">
                                <h4 class="font-bold text-lg">迁移学习与终身学习</h4>
                                <p class="text-sm mt-2">将在A机组上训练好的模型，快速适配到B机组上。并让模型在上线后能持续地在线学习，适应新情况。</p>
                            </div>
                        </div>
                    </div>
                `
            };
            
            Object.keys(chapterContents).forEach(key => {
                const section = document.getElementById(key);
                if (section) section.innerHTML = chapterContents[key];
            });


            // --- Global Variables & Selectors ---
            const homeLanding = document.getElementById('home-landing');
            const mainApp = document.getElementById('main-app');
            const startBtn = document.getElementById('start-experience-btn');
            const mainLogo = document.getElementById('main-logo');
            const navLinks = document.querySelectorAll('.nav-link');
            const contentSections = document.querySelectorAll('.content-section');
            
            // Modals
            const userPanel = document.getElementById('user-info-panel');
            const userModal = document.getElementById('user-modal');
            const closeUserModalBtn = document.getElementById('close-user-modal-btn');
            const contactBtn = document.getElementById('contact-btn');
            const contactModal = document.getElementById('contact-modal');
            const closeContactModalBtn = document.getElementById('close-contact-modal-btn');
            const contactForm = document.getElementById('contact-form');
            const contactSuccessMsg = document.getElementById('contact-success-msg');
            const contactIntro = document.getElementById('contact-intro');

            // Theme Toggle
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            let currentView = '';
            let activeAnimationFrames = {};

            // --- Theme Management ---
            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                    themeIcon.classList.replace('fa-moon', 'fa-sun');
                    themeText.textContent = '切换浅色模式';
                } else {
                    document.documentElement.classList.remove('dark');
                    themeIcon.classList.replace('fa-sun', 'fa-moon');
                    themeText.textContent = '切换深色模式';
                }
                // Re-render any visible canvas that depends on theme
                if(currentView) initializeInteractiveModules(currentView);
            }

            themeToggleBtn.addEventListener('click', () => {
                const isDark = document.documentElement.classList.contains('dark');
                const newTheme = isDark ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme);
                applyTheme(newTheme);
            });
            
            const savedTheme = localStorage.getItem('theme') || 'light';
            applyTheme(savedTheme);


            // --- Core Navigation & App Flow ---
            startBtn.addEventListener('click', () => {
                homeLanding.style.display = 'none';
                mainApp.style.display = 'block';
                navigateTo('chapter1');
            });

            mainLogo.addEventListener('click', () => {
                mainApp.style.display = 'none';
                homeLanding.style.display = 'flex';
                cleanupAnimations();
                currentView = 'home';
                window.history.pushState({view: 'home'}, '', '#');
            });

            // --- Modal Logic ---
            userPanel.addEventListener('click', () => userModal.classList.add('visible'));
            closeUserModalBtn.addEventListener('click', () => userModal.classList.remove('visible'));
            userModal.addEventListener('click', (e) => { if(e.target === userModal) userModal.classList.remove('visible'); });

            contactBtn.addEventListener('click', () => {
                contactSuccessMsg.classList.add('hidden');
                contactForm.classList.remove('hidden');
                contactIntro.classList.remove('hidden');
                contactModal.classList.add('visible');
            });
            closeContactModalBtn.addEventListener('click', () => contactModal.classList.remove('visible'));
            contactModal.addEventListener('click', (e) => { if(e.target === contactModal) contactModal.classList.remove('visible'); });
            contactForm.addEventListener('submit', (e) => {
                e.preventDefault();
                contactForm.classList.add('hidden');
                contactIntro.classList.add('hidden');
                contactSuccessMsg.classList.remove('hidden');
                setTimeout(() => {
                    contactModal.classList.remove('visible');
                    contactForm.reset();
                }, 2500);
            });


            function cleanupAnimations() {
                Object.values(activeAnimationFrames).forEach(id => {
                    if (id) cancelAnimationFrame(id);
                });
                activeAnimationFrames = {};
                if(window.acAnimationTimeoutId) clearTimeout(window.acAnimationTimeoutId);
                if(window.rlSimulationIntervalId) clearInterval(window.rlSimulationIntervalId);
            }

            function navigateTo(viewId) {
                if (!viewId || currentView === viewId) return;
                
                cleanupAnimations();
                currentView = viewId;
                
                navLinks.forEach(link => link.classList.toggle('active', link.dataset.view === viewId));
                contentSections.forEach(section => section.classList.toggle('active', section.id === viewId));
                
                initializeInteractiveModules(viewId);
                if(window.location.hash !== `#${viewId}`) {
                    window.history.pushState({view: viewId}, '', `#${viewId}`);
                }
            }

            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    navigateTo(link.dataset.view);
                });
            });

            window.addEventListener('popstate', (e) => {
                const viewId = e.state?.view || (window.location.hash ? window.location.hash.substring(1) : 'chapter1');
                 if (viewId && viewId !== 'home') {
                    homeLanding.style.display = 'none';
                    mainApp.style.display = 'block';
                    navigateTo(viewId);
                } else {
                    mainApp.style.display = 'none';
                    homeLanding.style.display = 'flex';
                }
            });

            const initialHash = window.location.hash.substring(1);
            if (initialHash && chapterContents[initialHash]) {
                startBtn.click();
                setTimeout(() => navigateTo(initialHash), 50);
            }

            function initializeInteractiveModules(viewId) {
                window.activeAnimationFrames = activeAnimationFrames;
                switch(viewId) {
                    case 'chapter1': initChapter1(); break;
                    case 'chapter2': initChapter2(); break;
                    case 'chapter4': initActorCriticViz(); break;
                    case 'chapter5': initPpoCanvas(); break;
                    case 'chapter6': initSacCanvas(); break;
                    case 'chapter7': initCmdpLab(); break;
                    case 'chapter8': initSimRealCanvas(); break; 
                    case 'chapter9': initRlTrainingLab(); break;
                    case 'chapter10': selectStep(1); break;
                }
                if (window.MathJax) MathJax.typesetPromise();
            }
        });

        // --- All interactive logic functions are defined below ---

        function initChapter1() {
            initBoilerSandbox();
            renderBoilerDiagram();
            renderRankineDiagram();
        }

        function initChapter2() {
            initBellmanGrid();
            renderRlTaxonomy();
        }
        
        function initBoilerSandbox() {
            const sliders = {
                load: document.getElementById('load-slider'),
                air: document.getElementById('air-total-slider'),
                tilt: document.getElementById('burner-tilt-slider'),
                ofa: document.getElementById('o2-dist-slider')
            };
            if (!sliders.load) return;

            const values = {
                load: document.getElementById('load-value'),
                air: document.getElementById('air-total-value'),
                tilt: document.getElementById('burner-tilt-value'),
                ofa: document.getElementById('o2-dist-value')
            };
            const visuals = {
                flame: document.getElementById('flame-visual'),
                nox: document.getElementById('nox-meter-fill'),
                co: document.getElementById('co-meter-fill'),
                efficiency: document.getElementById('efficiency-value')
            };
            
            const paretoCtx = document.getElementById('pareto-chart')?.getContext('2d');
            let paretoChart;
            let workingPointHistory = [];

            function updateBoilerSimulation() {
                const load = parseFloat(sliders.load.value);
                const air = parseFloat(sliders.air.value);
                const tilt = parseFloat(sliders.tilt.value);
                const ofa = parseFloat(sliders.ofa.value);
                
                values.load.textContent = load.toFixed(0);
                values.air.textContent = air.toFixed(0);
                values.tilt.textContent = tilt.toFixed(0);
                values.ofa.textContent = ofa.toFixed(0);

                const load_factor = load / 100;
                let nox_raw = (air * 1.2 - ofa * 1.5 + Math.abs(tilt) * 0.5) * (0.8 + load_factor * 0.4);
                let co_raw = (150 - air + (Math.abs(air - 85) * 0.4)) * (0.9 + load_factor * 0.2);
                let eff_base = 90.5 + load_factor * 2;
                let eff_air = 1 - Math.abs(air - (80 + load_factor * 5)) / 50;
                let eff_ofa = 1 - Math.abs(ofa - 35) / 40;
                let efficiency_raw = eff_base + (eff_air * 1.5) + (eff_ofa * 1) - (co_raw / 150);

                const nox = Math.max(10, Math.min(100, nox_raw));
                const co = Math.max(5, Math.min(100, co_raw));
                const efficiency = Math.max(88, Math.min(94.5, efficiency_raw));
                
                visuals.flame.style.height = `${(40 + (air / 100) * 60) * (0.8 + load_factor * 0.2)}%`;
                visuals.flame.style.transform = `translateY(${tilt * -1.5}px) skewX(${tilt * -0.5}deg)`;
                visuals.nox.style.width = `${nox}%`;
                visuals.co.style.width = `${co}%`;
                visuals.efficiency.textContent = efficiency.toFixed(2);

                updateParetoChart(efficiency, nox);
            }

            function generateParetoFront() {
                const front = [];
                for (let eff = 94.5; eff >= 90; eff -= 0.1) {
                    let nox = 30 + Math.pow(94.5 - eff, 2) * 2;
                    nox += (Math.random() - 0.5) * 5;
                    front.push({x: nox, y: eff});
                }
                return front.sort((a,b) => a.x - b.x);
            }

            function updateParetoChart(efficiency, nox) {
                if (!paretoCtx) return;
                
                const newPoint = {x: nox, y: efficiency};
                workingPointHistory.push(newPoint);
                if (workingPointHistory.length > 20) workingPointHistory.shift();

                if (paretoChart) paretoChart.destroy();
                
                const isDark = document.documentElement.classList.contains('dark');
                const gridColor = isDark ? 'rgba(148, 163, 184, 0.2)' : 'rgba(0, 0, 0, 0.1)';
                const textColor = isDark ? '#94a3b8' : '#475569';

                paretoChart = new Chart(paretoCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: '帕累托最优前沿', data: generateParetoFront(), borderColor: 'rgba(220, 38, 38, 0.5)', borderWidth: 2, borderDash: [5, 5], pointRadius: 0, showLine: true, fill: false,
                        },{
                            label: '历史轨迹', data: workingPointHistory, backgroundColor: 'rgba(100, 116, 139, 0.3)', pointRadius: 3,
                        },{
                            label: '当前工作点', data: [newPoint], backgroundColor: 'rgb(79, 70, 229)', pointRadius: 8, pointHoverRadius: 10,
                        }]
                    },
                    options: {
                        animation: false,
                        scales: { 
                            x: { title: { display: true, text: 'NOx 排放', color: textColor }, min: 20, max: 100, grid: { color: gridColor }, ticks: { color: textColor } }, 
                            y: { title: { display: true, text: '热效率 (%)', color: textColor }, min: 88, max: 95, grid: { color: gridColor }, ticks: { color: textColor } } 
                        },
                        plugins: { legend: { position: 'bottom', labels: { color: textColor } } }
                    }
                });
            }

            Object.values(sliders).forEach(slider => slider.addEventListener('input', updateBoilerSimulation));
            updateBoilerSimulation();
        }

        function initBellmanGrid() {
            const canvas = document.getElementById('bellman-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const iterateBtn = document.getElementById('iterate-bellman-btn');
            const resetBtn = document.getElementById('reset-bellman-btn');
            const iterCountEl = document.getElementById('bellman-iteration-count');
            const updateInfoEl = document.getElementById('bellman-update-info');
            const methodSelect = document.getElementById('dp-method-select');
            const phaseInfoEl = document.getElementById('pi-phase-info');

            const GRID_SIZE = 5;
            const GAMMA = 0.9;
            const REWARDS = { goal: 1, trap: -1, step: 0 };
            const goal = {x: 4, y: 4};
            const traps = [{x: 2, y: 2}, {x: 1, y: 3}];
            const walls = [{x: 3, y: 1}];

            let values, policy, iterationCount, pi_phase;

            function reset() {
                iterationCount = 0;
                values = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                policy = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(Math.floor(Math.random() * 4)));
                iterCountEl.textContent = iterationCount;
                updateInfoEl.textContent = '环境已重置。';
                pi_phase = 'evaluation';
                updatePhaseDisplay();
                drawGrid();
            }

            function iterate() {
                const method = methodSelect.value;
                if (method === 'vi') { valueIterationStep(); } 
                else { policyIterationStep(); }
                iterationCount++;
                iterCountEl.textContent = iterationCount;
                drawGrid();
            }
            
            function valueIterationStep() {
                let newValues = JSON.parse(JSON.stringify(values));
                let maxChange = 0;
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (isWall(x, y) || isTerminal(x, y)) continue;
                        const actionValues = getActionValues(x, y, values);
                        const bestValue = Math.max(...actionValues);
                        newValues[y][x] = REWARDS.step + GAMMA * bestValue;
                        maxChange = Math.max(maxChange, Math.abs(newValues[y][x] - values[y][x]));
                    }
                }
                values = newValues;
                updatePolicyBasedOnValues();
                updateInfoEl.textContent = `价值迭代。最大变化量: ${maxChange.toFixed(3)}`;
            }

            function policyIterationStep() {
                if (pi_phase === 'evaluation') {
                    let maxChange = 0;
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            if (isWall(x, y) || isTerminal(x, y)) continue;
                            const currentAction = policy[y][x];
                            const actionValue = getActionValues(x, y, values)[currentAction];
                            const newValue = REWARDS.step + GAMMA * actionValue;
                            maxChange = Math.max(maxChange, Math.abs(newValue - values[y][x]));
                            values[y][x] = newValue;
                        }
                    }
                    updateInfoEl.textContent = `策略评估。最大变化量: ${maxChange.toFixed(3)}`;
                    if (maxChange < 1e-3) pi_phase = 'improvement';
                } else { // improvement phase
                    let policy_stable = true;
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            if (isTerminal(x, y) || isWall(x, y)) continue;
                            let old_action = policy[y][x];
                            const actionValues = getActionValues(x, y, values);
                            policy[y][x] = actionValues.indexOf(Math.max(...actionValues));
                            if (old_action !== policy[y][x]) policy_stable = false;
                        }
                    }
                    updateInfoEl.textContent = `策略提升。策略稳定: ${policy_stable}`;
                    pi_phase = 'evaluation';
                }
                updatePhaseDisplay();
            }
            
            function getActionValues(x, y, value_grid) {
                const actions = [[0, -1], [0, 1], [-1, 0], [1, 0]]; // U, D, L, R
                return actions.map(([dx, dy]) => {
                    const nx = x + dx, ny = y + dy;
                    if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE || isWall(nx, ny)) {
                        return value_grid[y][x];
                    }
                    return value_grid[ny][nx];
                });
            }
            
            function updatePolicyBasedOnValues() {
                 for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (isTerminal(x, y) || isWall(x, y)) continue;
                        const actionValues = getActionValues(x, y, values);
                        policy[y][x] = actionValues.indexOf(Math.max(...actionValues));
                    }
                }
            }

            function isTerminal(x, y) { return (x === goal.x && y === goal.y) || traps.some(t => t.x === x && t.y === y); }
            function isWall(x, y) { return walls.some(w => w.x === x && w.y === y); }
            function updatePhaseDisplay() { phaseInfoEl.textContent = methodSelect.value === 'pi' ? (pi_phase === 'evaluation' ? '评估中' : '提升中') : 'N/A'; }

            function drawGrid() {
                const cellSize = canvas.width / GRID_SIZE;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const isDark = document.documentElement.classList.contains('dark');

                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const val = values[y][x];
                        const heat = (val - REWARDS.trap) / (REWARDS.goal - REWARDS.trap);
                        const r = Math.floor(255 * (1 - heat));
                        const g = Math.floor(255 * heat);
                        ctx.fillStyle = `rgb(${r}, ${g}, 100)`;
                        if (isWall(x, y)) ctx.fillStyle = '#555';
                        else if (isTerminal(x, y)) ctx.fillStyle = (x === goal.x && y === goal.y) ? 'rgb(100,255,100)' : 'rgb(255,100,100)';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        ctx.strokeStyle = isDark ? '#475569' : '#ccc';
                        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);

                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        if (isTerminal(x,y) || isWall(x,y)) {
                            ctx.font = `${cellSize*0.6}px sans-serif`;
                            if(x === goal.x && y === goal.y) ctx.fillText('🏆', x*cellSize+cellSize/2, y*cellSize+cellSize/2);
                            else if(isWall(x, y)) ctx.fillText('🧱', x*cellSize+cellSize/2, y*cellSize+cellSize/2);
                            else ctx.fillText('☠️', x*cellSize+cellSize/2, y*cellSize+cellSize/2);
                        } else {
                            ctx.fillStyle = isDark ? '#f1f5f9' : '#1e293b';
                            ctx.font = `bold ${cellSize*0.25}px sans-serif`;
                            ctx.fillText(val.toFixed(1), x*cellSize+cellSize/2, y*cellSize+cellSize/4);
                            if(policy[y][x] !== -1) {
                                 ctx.font = `${cellSize*0.4}px sans-serif`;
                                 ctx.fillText(['↑', '↓', '←', '→'][policy[y][x]], x*cellSize+cellSize/2, y*cellSize+cellSize*0.7);
                            }
                        }
                    }
                }
            }
            
            iterateBtn.addEventListener('click', iterate);
            resetBtn.addEventListener('click', reset);
            methodSelect.addEventListener('change', reset);
            reset();
        }
        
        function initActorCriticViz() {
            const container = document.getElementById('ac-diagram-container');
            if (!container) return;
            const playBtn = document.getElementById('play-ac-viz');
            const explanationEl = document.getElementById('ac-viz-explanation');
            
            renderAcDiagram(container);
            const svgEl = container.querySelector('svg');
            if (!svgEl) return;

            const allElements = {
                nodes: Array.from(svgEl.querySelectorAll(".ac-node")),
                arrows: Array.from(svgEl.querySelectorAll(".ac-arrow")),
                updateLabel: svgEl.querySelector("#label-update")
            };

            function resetHighlights() {
                allElements.nodes.forEach(el => el.classList.remove('highlight'));
                allElements.arrows.forEach(el => {
                    el.style.stroke = '#9ca3af';
                    el.setAttribute('marker-end', 'url(#arrowhead)');
                });
                if (allElements.updateLabel) allElements.updateLabel.style.fill = 'transparent';
                explanationEl.textContent = "";
            }

            playBtn.addEventListener('click', () => {
                if (playBtn.disabled) return;
                playBtn.disabled = true;
                if(window.acAnimationTimeoutId) clearTimeout(window.acAnimationTimeoutId);

                let stepIndex = 0;
                const steps = [
                    { el: ["node-state"], text: "1. 智能体观察到当前状态 S" },
                    { el: ["arrow-to-actor"], text: "2. 状态 S 被输入给演员 (Actor)" },
                    { el: ["node-actor"], text: "3. 演员根据其策略 $\\pi(a|S)$，选择一个动作 A" },
                    { el: ["arrow-to-action"], text: "4. 演员输出动作 A" },
                    { el: ["node-action"], text: "5. 动作 A 施加于环境" },
                    { el: ["arrow-to-env"], text: "6. 环境接收动作并发生状态转移" },
                    { el: ["node-env"], text: "7. 环境返回新状态S'和奖励R" },
                    { el: ["arrow-to-critic"], text: "8. (S, A, R, S') 被送往评论家进行评估" },
                    { el: ["node-critic"], text: "9. 评论家计算优势函数 A(s,a)" },
                    { el: ["arrow-critic-to-actor", "label-update"], text: "10. 优势函数 A(s,a) 指导演员更新" }
                ];

                function nextStep() {
                    resetHighlights();
                    if (stepIndex >= steps.length) {
                        playBtn.disabled = false;
                        explanationEl.textContent = "流程结束。";
                        if(window.MathJax) MathJax.typesetPromise();
                        return;
                    }

                    const currentStep = steps[stepIndex];
                    explanationEl.innerHTML = currentStep.text;
                    if(window.MathJax) MathJax.typesetPromise();

                    currentStep.el.forEach(id => {
                        const element = svgEl.querySelector(`#${id}`);
                        if (element) {
                            if (element.tagName.toLowerCase() === 'path') {
                                element.style.stroke = '#f97316';
                                element.setAttribute('marker-end', 'url(#arrowhead-h)');
                            } else if (id.includes('node')) {
                                element.classList.add('highlight');
                            } else if (id === 'label-update') {
                                element.style.fill = '#c2410c';
                            }
                        }
                    });

                    stepIndex++;
                    window.acAnimationTimeoutId = setTimeout(nextStep, 1800);
                }

                resetHighlights();
                nextStep();
            });
        }
            
        function initPpoCanvas() {
            const canvas = document.getElementById('ppo-canvas'); 
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const toggleBtn = document.getElementById('ppo-toggle-advantage');
            const explanationEl = document.getElementById('ppo-explanation');
            const epsilonSlider = document.getElementById('epsilon-slider');
            const epsilonValueEl = document.getElementById('epsilon-value');
            let advantage = 1;
            let epsilon = 0.2;

            function drawPpo(){
                const w = canvas.width, h = canvas.height;
                const isDark = document.documentElement.classList.contains('dark');
                ctx.clearRect(0, 0, w, h);
                
                ctx.strokeStyle = isDark ? '#475569' : '#cbd5e1';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
                const r1_x = w * (1 - 0.5) / 1.5;
                ctx.moveTo(r1_x, 0); ctx.lineTo(r1_x, h);
                ctx.stroke();
                ctx.fillStyle = isDark ? '#94a3b8' : '#64748b';
                ctx.font = "12px 'Noto Sans SC'";
                ctx.fillText('r(θ)=1', r1_x - 10, h/2 + 15);
                ctx.fillText('目标 L', w/2 - 20, 15);
                ctx.fillText('概率比 r(θ)', w - 60, h/2 + 15);
                
                ctx.fillStyle = 'rgba(79, 70, 229, 0.05)';
                const clip_lower_x = w * (1 - epsilon - 0.5) / 1.5;
                const clip_upper_x = w * (1 + epsilon - 0.5) / 1.5;
                ctx.fillRect(clip_lower_x, 0, clip_upper_x - clip_lower_x, h);

                ctx.strokeStyle = '#fca5a5';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1.5;
                const y_clip_upper = h/2 - 50 * (1 + epsilon) * advantage;
                const y_clip_lower = h/2 - 50 * (1 - epsilon) * advantage;
                ctx.beginPath(); ctx.moveTo(0, y_clip_upper); ctx.lineTo(w, y_clip_upper); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, y_clip_lower); ctx.lineTo(w, y_clip_lower); ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i <= w; i++) {
                    const ratio = 0.5 + (i / w) * 1.5;
                    const y_unclipped = h/2 - 50 * ratio * advantage;
                    const y_clipped_val = h/2 - 50 * (ratio > 1 ? (1+epsilon) : (1-epsilon)) * advantage;
                    const y_final = (advantage > 0) ? Math.max(y_unclipped, y_clipped_val) : Math.min(y_unclipped, y_clipped_val);
                    i === 0 ? ctx.moveTo(i, y_final) : ctx.lineTo(i, y_final);
                }
                ctx.stroke();

                if (advantage > 0) {
                    explanationEl.innerHTML = '当优势 $\\hat{A}_t > 0$ (好动作)时，目标函数被 <span class="text-green-600 font-semibold">向上推动</span>，但被上限裁剪，防止策略过于激进。';
                } else {
                    explanationEl.innerHTML = '当优势 $\\hat{A}_t < 0$ (坏动作)时，目标函数被 <span class="text-red-600 font-semibold">向下拉动</span>，但被下限裁剪，防止策略更新过猛。';
                }
                if(window.MathJax) MathJax.typesetPromise();
            }
            
            toggleBtn.addEventListener('click', () => {
                advantage *= -1;
                toggleBtn.innerHTML = advantage > 0 ? '切换到 "坏动作" ($\\hat{A}_t < 0$)' : '切换到 "好动作" ($\\hat{A}_t > 0$)';
                if(window.MathJax) MathJax.typesetPromise();
                drawPpo();
            });
            epsilonSlider.addEventListener('input', (e) => {
                epsilon = parseFloat(e.target.value);
                epsilonValueEl.textContent = epsilon.toFixed(2);
                drawPpo();
            });
            drawPpo();
        }
            
        function initSacCanvas() {
            const sacCanvas = document.getElementById('sac-canvas'); 
            if (!sacCanvas) return;
            const sacCtx = sacCanvas.getContext('2d');
            const slider = document.getElementById('alpha-slider');
            const valueDisp = document.getElementById('alpha-value');
            const explanationEl = document.getElementById('sac-explanation');
            let alpha = 0.2;
            
            slider.addEventListener('input', (e) => {
                alpha = parseFloat(e.target.value);
                valueDisp.textContent = alpha.toFixed(2);
            });
            
            const rewardLandscape = (x_norm) => Math.sin(x_norm * 2 * Math.PI) * 0.5 + Math.cos(x_norm * 3 * Math.PI) * 0.3;
            let animationTime = 0;

            function drawSac() {
                if (!document.getElementById('sac-canvas')) {
                    if (window.activeAnimationFrames.sac) cancelAnimationFrame(window.activeAnimationFrames.sac);
                    return;
                }
                const w = sacCanvas.width, h = sacCanvas.height;
                sacCtx.clearRect(0, 0, w, h);
                
                sacCtx.beginPath();
                sacCtx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                sacCtx.lineWidth = 2;
                sacCtx.setLineDash([2, 3]);
                for (let x = 0; x <= w; x++) {
                    const y = h/2 - rewardLandscape(x / w) * h/3;
                    x === 0 ? sacCtx.moveTo(x, y) : sacCtx.lineTo(x, y);
                }
                sacCtx.stroke();
                sacCtx.setLineDash([]);
                
                sacCtx.beginPath();
                sacCtx.fillStyle = 'rgba(79, 70, 229, 0.5)';
                const std_dev = 0.05 + alpha * 0.4;
                animationTime += 0.005;
                const mean = w / 2 + Math.sin(animationTime) * w/3;
                
                sacCtx.moveTo(0, h);
                for (let x = 0; x <= w; x++) {
                    const y = Math.exp(-0.5 * Math.pow(((x - mean) / (w/4)) / std_dev, 2)) * (h - 20);
                    sacCtx.lineTo(x, h - y);
                }
                sacCtx.lineTo(w, h);
                sacCtx.closePath();
                sacCtx.fill();
                
                if (alpha > 0.6) explanationEl.textContent = '高 α: 策略非常平坦, 熵奖励主导, 智能体积极探索。';
                else if (alpha < 0.1) explanationEl.textContent = '低 α: 策略非常尖锐, 任务奖励主导, 智能体积极利用。';
                else explanationEl.textContent = 'α 适中: 在探索与利用之间取得良好平衡。';

                window.activeAnimationFrames.sac = requestAnimationFrame(drawSac);
            }
            drawSac();
        }

        function initCmdpLab() {
            const builderPanel = document.getElementById('cmdp-builder-panel');
            if (!builderPanel) return;

            const checkboxes = builderPanel.querySelectorAll('.cmdp-checkbox');
            const controls = {
                air: document.getElementById('air-slider-ch7'),
                tilt: document.getElementById('tilt-slider-ch7'),
                ofa: document.getElementById('ofa-slider-ch7'),
            };
            const valueLabels = {
                air: document.getElementById('air-value-ch7'),
                tilt: document.getElementById('tilt-value-ch7'),
                ofa: document.getElementById('ofa-value-ch7'),
            };
            const visuals = {
                flame: document.getElementById('flame-visual-ch7'),
                noxFill: document.getElementById('nox-meter-fill-ch7'),
                coFill: document.getElementById('co-meter-fill-ch7'),
                tempFill: document.getElementById('temp-meter-fill-ch7'),
                efficiency: document.getElementById('efficiency-value-ch7'),
            };

            function updateSimulation() {
                if (!controls.air || !controls.tilt || !controls.ofa) return;
                const air = parseFloat(controls.air.value);
                const tilt = parseFloat(controls.tilt.value);
                const ofa = parseFloat(controls.ofa.value);

                if (valueLabels.air) valueLabels.air.textContent = air.toFixed(0);
                if (valueLabels.tilt) valueLabels.tilt.textContent = tilt.toFixed(0);
                if (valueLabels.ofa) valueLabels.ofa.textContent = ofa.toFixed(0);

                let nox = 1.1 * air - 1.6 * ofa + 0.4 * Math.abs(tilt);
                let co = 140 - air + 0.5 * Math.abs(air - 80);
                let temp = 60 + (air - 75) + Math.abs(tilt);
                let efficiency = 91.5 + (1 - Math.abs(air - 85) / 50) * 1.5 + (1 - Math.abs(ofa - 35) / 40) * 1 - (co / 100);

                nox = Math.max(10, Math.min(100, nox));
                co = Math.max(5, Math.min(100, co));
                temp = Math.max(20, Math.min(100, temp));
                efficiency = Math.max(90, Math.min(94, efficiency));

                if (visuals.flame) {
                    visuals.flame.style.height = `${30 + (air / 100) * 70}%`;
                    visuals.flame.style.transform = `translateY(${tilt * -1.5}px) skewX(${tilt * -0.5}deg)`;
                }
                if (visuals.noxFill) visuals.noxFill.style.width = `${nox}%`;
                if (visuals.coFill) visuals.coFill.style.width = `${co}%`;
                if (visuals.tempFill) visuals.tempFill.style.width = `${temp}%`;
                if (visuals.efficiency) visuals.efficiency.textContent = efficiency.toFixed(2);
            }

            function updateSummary() {
                const summary = { State: [], Action: [], Reward: [], Cost: [] };
                checkboxes.forEach(cb => {
                    if (cb.checked) {
                        const label = cb.parentElement.textContent.trim();
                        const header = cb.closest('div.space-y-2').previousElementSibling.textContent;
                        if (header.includes('状态')) summary.State.push(label);
                        else if (header.includes('动作')) summary.Action.push(label);
                        else if (header.includes('奖励')) summary.Reward.push(label);
                        else if (header.includes('成本')) summary.Cost.push(label);
                    }
                });
                
                const renderList = (key) => {
                    const list = summary[key];
                    const el = document.getElementById(`summary-${key}-ch7`);
                    if(el) el.innerHTML = list.length ? list.map(item => `<li>${item}</li>`).join('') : '<li>未选</li>';
                }
                ['State', 'Action', 'Reward', 'Cost'].forEach(renderList);
            }

            checkboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    const targetEl = document.getElementById(cb.dataset.target);
                    if (!targetEl) return;
                    targetEl.classList.toggle('hidden', !cb.checked);
                    
                    targetEl.classList.remove('reward-highlight', 'cost-highlight');
                    if (cb.checked) {
                        if (cb.dataset.type === 'reward') targetEl.classList.add('reward-highlight');
                        else if (cb.dataset.type === 'cost') targetEl.classList.add('cost-highlight');
                    }
                    updateSummary();
                });
            });

            Object.values(controls).forEach(slider => {
                if(slider) slider.addEventListener('input', updateSimulation);
            });
            updateSimulation();
            updateSummary();
        }

        function initSimRealCanvas() {
            const canvas = document.getElementById('sim-real-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('model-quality-slider');
            const valueDisp = document.getElementById('model-quality-value');
            let quality = 50;

            if (slider) slider.oninput = (e) => {
                quality = parseInt(e.target.value);
                if (valueDisp) valueDisp.textContent = quality;
            };

            let time = 0;
            const draw = () => {
                if(!document.getElementById('sim-real-canvas')) {
                    if(window.activeAnimationFrames.simReal) cancelAnimationFrame(window.activeAnimationFrames.simReal);
                    return;
                }
                const w = canvas.width, h = canvas.height;
                const isDark = document.documentElement.classList.contains('dark');
                ctx.clearRect(0, 0, w, h);
                time += 0.01;

                ctx.beginPath(); 
                ctx.strokeStyle = isDark ? '#f1f5f9' : '#1e293b'; 
                ctx.lineWidth = 3;
                for (let x = 0; x < w; x++) {
                    const y = h / 2 + Math.sin(x * 0.03 + time) * h / 6 + Math.cos(x * 0.07 + time) * h / 8;
                    x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.stroke();

                ctx.beginPath(); 
                ctx.strokeStyle = '#3b82f6'; 
                ctx.lineWidth = 2; 
                ctx.setLineDash([5, 5]);
                const noise_amplitude = (100 - quality) / 100 * h / 3;
                for (let x = 0; x < w; x++) {
                    const real_y = h / 2 + Math.sin(x * 0.03 + time) * h / 6 + Math.cos(x * 0.07 + time) * h / 8;
                    const sim_y = real_y + (Math.random() - 0.5) * noise_amplitude;
                    x === 0 ? ctx.moveTo(x, sim_y) : ctx.lineTo(x, sim_y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
                window.activeAnimationFrames.simReal = requestAnimationFrame(draw);
            };
            draw();
        }

        function initRlTrainingLab() {
            const canvas = document.getElementById('rl-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const chartCtx = document.getElementById('rewardChart')?.getContext('2d');
            if (!chartCtx) return;

            const GRID_SIZE = 8;
            const GOAL = { x: GRID_SIZE - 1, y: GRID_SIZE - 1 };
            const TRAPS = [{x: 2,y: 2},{x: 2,y: 3},{x: 3,y: 2},{x: 5,y: 5},{x: 6,y: 5}];
            
            let agent, q_table, episode, totalReward, rewardHistory, rewardChart, simParams;

            const sliders = {
                gamma: document.getElementById('gamma-slider'),
                lr: document.getElementById('lr-slider'),
                epsilon: document.getElementById('epsilon-slider-ch9'),
            };
            const valueLabels = {
                gamma: document.getElementById('gamma-value'),
                lr: document.getElementById('lr-value'),
                epsilon: document.getElementById('epsilon-value-ch9'),
            };

            function setupParams() {
                simParams = {
                    gamma: parseFloat(sliders.gamma.value),
                    lr: parseFloat(sliders.lr.value),
                    epsilon: parseFloat(sliders.epsilon.value),
                };
                valueLabels.gamma.textContent = simParams.gamma.toFixed(2);
                valueLabels.lr.textContent = simParams.lr.toFixed(2);
                valueLabels.epsilon.textContent = simParams.epsilon.toFixed(2);
            }
            
            function resetSimulation() {
                if (window.rlSimulationIntervalId) clearInterval(window.rlSimulationIntervalId);
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                q_table = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0).map(() => [0, 0, 0, 0]));
                episode = 0;
                totalReward = 0;
                rewardHistory = [];

                setupParams();
                resetChart();
                updateCounters();

                window.rlSimulationIntervalId = setInterval(runEpisode, 50);
            }

            function runEpisode() {
                if (episode > 1000) {
                    clearInterval(window.rlSimulationIntervalId);
                    return;
                }
                agent = { x: 0, y: 0 };
                let episodeReward = 0, done = false, steps = 0;

                while (!done && steps < 50) {
                    const state = { x: agent.x, y: agent.y };
                    const action = chooseAction(state);
                    const nextState = getNextState(state, action);
                    const reward = getReward(nextState);
                    
                    const old_q = q_table[state.y][state.x][action];
                    const next_max_q = Math.max(...q_table[nextState.y][nextState.x]);
                    q_table[state.y][state.x][action] = old_q + simParams.lr * (reward + simParams.gamma * next_max_q - old_q);

                    agent = nextState;
                    episodeReward += reward;
                    steps++;
                    done = isTerminal(nextState);
                }
                
                episode++;
                rewardHistory.push(episodeReward);
                updateChart();
                updateCounters();
                drawGrid();
            }

            function chooseAction(state) {
                if (Math.random() < simParams.epsilon) return Math.floor(Math.random() * 4);
                const q_values = q_table[state.y][state.x];
                return q_values.indexOf(Math.max(...q_values));
            }

            function getNextState({x,y}, action) {
                if (action === 0) y = Math.max(0, y - 1);
                else if (action === 1) y = Math.min(GRID_SIZE - 1, y + 1);
                else if (action === 2) x = Math.max(0, x - 1);
                else if (action === 3) x = Math.min(GRID_SIZE - 1, x + 1);
                return { x, y };
            }

            function getReward(state) {
                if (state.x === GOAL.x && state.y === GOAL.y) return 100;
                if (TRAPS.some(t => t.x === state.x && t.y === state.y)) return -100;
                return -1;
            }
            
            function isTerminal(state) {
                return (state.x === GOAL.x && state.y === GOAL.y) || TRAPS.some(t => t.x === state.x && t.y === state.y);
            }
            
            function drawGrid() {
                const cellSize = canvas.width / GRID_SIZE;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const isDark = document.documentElement.classList.contains('dark');

                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if(TRAPS.some(t => t.x === x && t.y === y)) ctx.fillStyle = isDark ? '#450a0a' : '#fee2e2';
                        else if(GOAL.x === x && GOAL.y === y) ctx.fillStyle = isDark ? '#064e3b' : '#dcfce7';
                        else ctx.fillStyle = isDark ? '#334155' : '#f1f5f9';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);

                        if (!isTerminal({x,y})) {
                            const max_q = Math.max(...q_table[y][x]);
                            const bestAction = q_table[y][x].indexOf(max_q);
                            ctx.fillStyle = isDark ? '#cbd5e1' : 'rgba(0, 0, 0, 0.6)';
                            ctx.font = `${cellSize * 0.4}px sans-serif`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(['↑', '↓', '←', '→'][bestAction], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
                        }
                    }
                }
                
                ctx.font = `${cellSize * 0.6}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('S', cellSize / 2, cellSize / 2);
                ctx.fillText('🏆', GOAL.x * cellSize + cellSize / 2, GOAL.y * cellSize + cellSize / 2);
                TRAPS.forEach(t => ctx.fillText('☠️', t.x * cellSize + cellSize / 2, t.y * cellSize + cellSize / 2));

                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(agent.x * cellSize + cellSize / 2, agent.y * cellSize + cellSize / 2, cellSize / 3.5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            function resetChart() {
                if (rewardChart) rewardChart.destroy();
                const isDark = document.documentElement.classList.contains('dark');
                const textColor = isDark ? '#94a3b8' : '#475569';
                const gridColor = isDark ? 'rgba(148, 163, 184, 0.2)' : 'rgba(0, 0, 0, 0.1)';

                rewardChart = new Chart(chartCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: '最近20回合平均奖励', data: [], borderColor: '#16a34a', tension: 0.2, pointRadius: 0, fill: true, backgroundColor: 'rgba(22, 163, 74, 0.1)' }] },
                    options: { responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { title: { display: true, text: '奖励', color: textColor }, grid: { color: gridColor }, ticks: { color: textColor } } }, plugins: { legend: { display: false } } }
                });
            }

            function updateChart() {
                if (!rewardChart || episode % 10 !== 0) return;
                const recentRewards = rewardHistory.slice(-20);
                totalReward = recentRewards.reduce((a, b) => a + b, 0) / recentRewards.length;
                
                rewardChart.data.labels.push(episode);
                rewardChart.data.datasets[0].data.push(totalReward);
                if (rewardChart.data.labels.length > 50) {
                    rewardChart.data.labels.shift();
                    rewardChart.data.datasets[0].data.shift();
                }
                rewardChart.update('none');
            }

            function updateCounters() {
                document.getElementById('episode-counter').textContent = episode;
                document.getElementById('total-reward').textContent = totalReward.toFixed(2);
            }
            
            document.getElementById('start-sim').addEventListener('click', resetSimulation);
            Object.values(sliders).forEach(slider => slider.addEventListener('input', setupParams));
            resetSimulation();
        }

        function selectStep(step) {
            const contentEl = document.getElementById('step-content');
            if (!contentEl) return;
            const content = {
                1: { title: "阶段一：建议模式 (Advisory Mode)", description: "RL智能体以“影子模式”运行，实时接收电厂数据并计算最优动作。但这些动作并<strong>不</strong>直接执行，而是作为操作建议显示在操作员站的界面上，由经验丰富的人工操作员确认后执行。", goals: ["在零风险下验证AI策略的长期性能。", "让操作员逐步熟悉和信任AI的决策逻辑。", "收集对比数据，量化AI相比纯人工操作的具体提升。"], risk_mitigation: "操作员拥有100%的最终控制权，AI无任何物理执行能力，实现绝对安全。" },
                2: { title: "阶段二：监督控制 (Supervisory Control)", description: "AI的输出不再是直接的阀门动作，而是调整DCS中现有PID控制回路的<strong>设定值</strong>。例如，AI决定将“总风量PID”的目标值从50%调整到55%。", goals: ["在不改变底层可靠控制结构的前提下，实现更高层级的优化。", "利用现有DCS系统的稳定性和安全联锁作为底层安全网。", "在真实的闭环反馈下对模型进行在线微调。"], risk_mitigation: "智能体的作用范围被限制在高层设定值，底层的快速调节和安全保护仍由久经考验的PID系统完成，极大降低了风险。" },
                3: { title: "阶段三：直接控制 (Direct Control)", description: "AI获得对执行机构的直接控制权。但其输出的所有指令在发送给DCS之前，必须强制通过一个最终的、硬编码的<strong>安全层 (Safety Layer)</strong>。", goals: ["实现完全的自主优化，对工况变化做出最快速、最直接的响应。", "最大化RL策略的性能。"], risk_mitigation: "“安全层”是一个非AI的、基于简单规则的程序。它会检查AI的每一个指令，并立即否决任何可能违反硬性安全约束的动作。这是对抗AI不可预见行为的最后一道防线。" }
            };
            for (let i = 1; i <= 3; i++) document.getElementById(`step${i}`)?.classList.toggle('active', i === step);
            const selectedContent = content[step];
            if (selectedContent) {
                contentEl.innerHTML = `<h3 class="text-xl font-bold mb-4">${selectedContent.title}</h3><p class="text-themed-secondary mb-4">${selectedContent.description}</p><h4 class="font-bold text-lg mb-2">主要目标:</h4><ul class="list-disc list-inside space-y-1 text-themed-secondary mb-4">${selectedContent.goals.map(g => `<li>${g}</li>`).join('')}</ul><h4 class="font-bold text-lg mb-2">风险控制:</h4><p class="p-3 bg-green-500/10 border border-green-500/20 text-green-700 dark:text-green-300 rounded-lg">${selectedContent.risk_mitigation}</p>`;
            }
        }

        function renderBoilerDiagram() {
            const container = document.getElementById('boiler-diagram-container');
            if (!container) return;
            container.innerHTML = `<svg viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg"><style>.txt{font-size:8px; font-family: 'Noto Sans SC', sans-serif; text-anchor: middle; fill: var(--text-secondary);} .line{stroke: var(--text-secondary); fill: none;} .arr{marker-end: url(#arrow); stroke-width: 0.8; stroke: var(--text-secondary); fill: none;}</style><defs><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="var(--text-secondary)"/></marker></defs><rect x="100" y="20" width="100" height="160" fill="var(--bg-muted)" stroke="var(--border-color)" stroke-width="1.5"/><text x="150" y="15" class="txt">锅炉</text><path d="M120,20 v-10 h60 v10" class="line" stroke-width="1.5"/><path d="M145,10 v-5 h10 v5" class="line" stroke-width="1.5"/><text x="150" y="7" class="txt" fill="#c2410c">过热蒸汽</text><rect x="110" y="100" width="80" height="40" fill="#fef9c3" stroke="#facc15" /><text x="150" y="125" class="txt">燃烧区</text><path d="M100,140 h-20 v-10 h20" class="arr" /><text x="65" y="135" class="txt">燃料+空气</text><path d="M200,160 h20 v-10 h-20" class="arr" /><text x="225" y="155" class="txt">灰渣</text><rect x="230" y="60" width="50" height="80" fill="#dbeafe" stroke="#60a5fa" stroke-width="1"/><text x="255" y="55" class="txt">汽轮机</text><path d="M150,25 h80 v40" class="arr" /><rect x="230" y="150" width="50" height="30" fill="#e0f2fe" stroke="#38bdf8" stroke-width="1"/><text x="255" y="145" class="txt">冷凝器</text><path d="M255,140 v-35" class="arr" /><rect x="40" y="160" width="50" height="20" fill="#dcfce7" stroke="#4ade80" stroke-width="1"/><text x="65" y="155" class="txt">给水泵</text><path d="M255,180 h-190 v-15" class="arr" /><path d="M40,170 h-10 v-20 h80" class="arr" /></svg>`;
        }

        function renderRankineDiagram() {
            const container = document.getElementById('rankine-diagram-container');
            if (!container) return;
            container.innerHTML = `<svg viewBox="0 0 200 150" xmlns="http://www.w3.org/2000/svg"><style>.txt{font-size:7px; font-family: 'Noto Sans SC', sans-serif; fill: var(--text-primary);} .lbl{font-size:6px; fill: var(--text-secondary);} .line{stroke-width:1; stroke:var(--text-secondary); fill:none;} .cycle{stroke-width:1.5; stroke:#ef4444; fill:none; marker-end: url(#arrow-red);}</style><defs><marker id="arrow-red" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="3" markerHeight="3" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#ef4444"/></marker></defs><path d="M20,140 L20,10 L180,10" class="line" /><text x="15" y="15" class="txt" text-anchor="end">T</text><text x="180" y="15" class="txt" text-anchor="end">s</text><path d="M40,120 C 80,120 80,40 120,40" class="line" /><text x="80" y="30" class="lbl">饱和蒸汽线</text><path d="M40,120 C 30,80 30,40 40,30" class="line" /><text x="35" y="25" class="lbl">饱和液体线</text><path d="M45,115 L45,80" class="cycle"/><text x="38" y="100" class="txt">1→2</text><text x="52" y="100" class="lbl">(泵)</text><path d="M45,80 C60,78 140,75 160,45" class="cycle"/><text x="40" y="78" class="txt"></text><text x="90" y="65" class="lbl">(锅炉)</text><path d="M160,45 L170,105" class="cycle"/><text x="158" y="40" class="txt">2→3</text><text x="175" y="70" class="lbl">(汽轮机)</text><path d="M170,105 L45,115" class="cycle"/><text x="173" y="108" class="txt">3→4</text><text x="110" y="120" class="lbl">(冷凝器)</text></svg>`;
        }

        function renderRlTaxonomy() {
            const container = document.getElementById('rl-taxonomy-container');
            if (!container) return;
            container.innerHTML = `<svg viewBox="0 0 250 150" xmlns="http://www.w3.org/2000/svg"><style>.box{fill:var(--bg-secondary); stroke:var(--accent-color); rx:3;} .txt{font-size:8px; font-family: 'Noto Sans SC', sans-serif; text-anchor:middle; fill: var(--text-primary);} .line{stroke:var(--text-secondary); stroke-width:0.5;}</style><rect x="85" y="5" width="80" height="15" class="box" /><text x="125" y="14" class="txt">强化学习</text><line x1="125" y1="20" x2="125" y2="30" class="line" /><line x1="60" y1="30" x2="190" y2="30" class="line" /><line x1="60" y1="30" x2="60" y2="40" class="line" /><line x1="190" y1="30" x2="190" y2="40" class="line" /><rect x="20" y="40" width="80" height="15" class="box" /><text x="60" y="49" class="txt">基于模型</text><rect x="150" y="40" width="80" height="15" class="box" /><text x="190" y="49" class="txt">无模型</text><line x1="190" y1="55" x2="190" y2="65" class="line" /><line x1="155" y1="65" x2="225" y2="65" class="line" /><line x1="155" y1="65" x2="155" y2="75" class="line" /><line x1="225" y1="65" x2="225" y2="75" class="line" /><rect x="115" y="75" width="80" height="15" class="box" /><text x="155" y="84" class="txt">基于策略</text><rect x="185" y="75" width="80" height="15" class="box" /><text x="225" y="84" class="txt">基于价值</text><line x1="155" y1="90" x2="155" y2="100" class="line" /><rect x="115" y="100" width="80" height="15" style="fill:#dcfce7; stroke:#4ade80;" /><text x="155" y="109" class="txt">PPO</text><line x1="225" y1="90" x2="225" y2="100" class="line" /><rect x="185" y="100" width="80" height="15" style="fill:#fef9c3; stroke:#facc15;" /><text x="225" y="109" class="txt">DQN</text><path d="M155,90 C175,95 205,95 225,90" fill="none" class="line"/><line x1="190" y1="92.5" x2="190" y2="120" class="line"/><text x="190" y="108" class="txt">演员-评论家</text><rect x="150" y="120" width="80" height="15" style="fill:#fbcfe8; stroke:#f472b6;" /><text x="190" y="129" class="txt">SAC / DDPG</text></svg>`;
        }

        function renderAcDiagram(container) {
            if (!container) return;
            container.innerHTML = `<svg id="ac-viz-svg" viewBox="0 0 400 300" class="w-full max-w-lg"><defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="5" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#9ca3af" /></marker><marker id="arrowhead-h" markerWidth="10" markerHeight="7" refX="5" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#f97316" /></marker></defs><style>.ac-node rect { transition: all 0.3s ease; transform-origin: center; } .ac-node.highlight rect { stroke-width:3; transform: scale(1.05); stroke: #f97316; } .ac-arrow { transition: stroke 0.3s ease; } text { fill: var(--text-primary); font-size:12px; font-family: 'Noto Sans SC', sans-serif; text-anchor: middle; }</style><g class="ac-node" id="node-state"><rect x="10" y="30" width="80" height="40" rx="5" fill="var(--bg-secondary)" stroke="var(--border-color)" stroke-width="2" /></g><text x="50" y="25">状态 S</text><path class="ac-arrow" id="arrow-to-actor" d="M95,50 C140,50 140,90 185,90" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><g class="ac-node" id="node-actor"><rect x="185" y="85" width="80" height="40" rx="20" fill="#eff6ff" stroke="#60a5fa" stroke-width="2" /></g><text x="225" y="80">演员 Actor</text><path class="ac-arrow" id="arrow-to-action" d="M225,130 Q225,150 225,170" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><g class="ac-node" id="node-action"><rect x="185" y="170" width="80" height="40" rx="5" fill="var(--bg-secondary)" stroke="var(--border-color)" stroke-width="2" /></g><text x="225" y="165">动作 A</text><path class="ac-arrow" id="arrow-to-env" d="M180,190 C140,190 140,230 105,230" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><g class="ac-node" id="node-env"><rect x="25" y="225" width="80" height="40" rx="20" fill="#fff7ed" stroke="#fb923c" stroke-width="2" /></g><text x="65" y="220">环境 Env</text><path class="ac-arrow" id="arrow-to-critic" d="M110,245 C160,245 250,245 295,245" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><text x="200" y="265" font-size="10">奖励 R, 新状态 S'</text><g class="ac-node" id="node-critic"><rect x="300" y="225" width="80" height="40" rx="20" fill="#f0fdf4" stroke="#4ade80" stroke-width="2" /></g><text x="340" y="220">评论家 Critic</text><path class="ac-arrow" id="arrow-critic-to-actor" d="M340,220 C340,150 270,150 265,125" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5" /><g id="label-update"><text x="310" y="170" font-weight="bold" font-size="12" fill="transparent">优势 A(s,a)</text></g></svg>`;
        }

    </script>
</body>
</html>
