<!DOCTYPE html>
<html lang="zh-CN" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能锅炉强化学习优化平台 (Pro版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --bg-primary: #f8fafc; --bg-secondary: #ffffff; --bg-muted: #f1f5f9;
            --text-primary: #1e293b; --text-secondary: #475569; --border-color: #e2e8f0;
            --accent-color: #4f46e5; --accent-text: #ffffff;
            --card-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.07), 0 2px 4px -2px rgb(0 0 0 / 0.07);
            --card-shadow-hover: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --glow-color: rgba(79, 70, 229, 0.2);
        }
        .dark {
            --bg-primary: #0f172a; --bg-secondary: #1e293b; --bg-muted: #334155;
            --text-primary: #f1f5f9; --text-secondary: #94a3b8; --border-color: #334155;
            --accent-color: #6366f1; --accent-text: #ffffff;
            --card-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --card-shadow-hover: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -4px rgb(0 0 0 / 0.2);
            --glow-color: rgba(99, 102, 241, 0.3);
        }
        html { scroll-padding-top: 80px; }
        body { 
            font-family: 'Noto Sans SC', sans-serif; 
            background-color: var(--bg-primary); 
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* Animations & Transitions */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        #content-container { animation: fadeIn 0.5s ease-out; }

        /* Navigation */
        .dropdown-menu { display: none; animation: fadeIn 0.2s ease-out; }
        .dropdown.open .dropdown-menu { display: block; }
        .nav-link.active { font-weight: bold; color: var(--accent-color); }
        .nav-link-completed::after {
            content: '✔'; color: #22c55e; font-weight: bold; margin-left: auto;
        }
        .nav-dropdown-btn.active {
            background-color: var(--bg-muted); color: var(--accent-color);
        }

        /* Components */
        .card { 
            background-color: var(--bg-secondary); border-radius: 0.75rem; 
            box-shadow: var(--card-shadow); transition: all 0.3s ease-in-out; 
            border: 1px solid var(--border-color); 
        }
        .card:hover { 
            transform: translateY(-4px); box-shadow: var(--card-shadow-hover), 0 0 20px var(--glow-color); 
        }
        h2 { 
            border-bottom: 2px solid var(--border-color); color: var(--text-primary); 
            font-size: 2.25rem; font-weight: 800; padding-bottom: 0.5rem; margin-bottom: 1.5rem;
        }
        h3 { 
            color: var(--text-primary); font-size: 1.5rem; font-weight: 700; 
            margin-top: 2rem; margin-bottom: 1rem;
        }
        
        /* Modal styles */
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 50; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal-backdrop.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--bg-secondary); padding: 2rem; border-radius: 0.75rem; max-width: 90%; width: 420px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-backdrop.visible .modal-content { transform: scale(1); }

        /* Other visual styles */
        .flame-visual { position: absolute; bottom: 0; left: 50%; transform-origin: bottom center; width: 60%; margin-left: -30%; background: linear-gradient(to top, #ffde00, #ff8c00, rgba(255,140,0,0)); border-radius: 50% 50% 10% 10% / 100% 100% 20% 20%; transition: all 0.4s ease-in-out; animation: flicker-animation 0.3s infinite alternate; }
        #boiler-visual-container, #boiler-visual-container-ch7 { box-shadow: inset 0 0 15px rgba(0,0,0,0.5); border: 3px solid #475569; }
        @keyframes flicker-animation { 
            0% { transform: scaleY(1) skewX(0deg); opacity: 0.9; filter: brightness(1); } 
            50% { transform: scaleY(0.95) skewX(3deg); opacity: 1; filter: brightness(1.1); } 
            100% { transform: scaleY(1.05) skewX(-3deg); opacity: 0.95; filter: brightness(1.2); } 
        }
        .deployment-step { transition: all 0.3s ease; border-left-width: 4px; border-color: transparent; }
        .deployment-step.active { border-color: var(--accent-color); background-color: rgba(79, 70, 229, 0.1); }
        pre { background-color: var(--bg-muted); padding: 1rem; border-radius: 0.5rem; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.9em; color: var(--text-primary); position: relative; }
        .copy-btn { position: absolute; top: 0.5rem; right: 0.5rem; background-color: var(--border-color); color: var(--text-secondary); border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer; opacity: 0.5; transition: opacity 0.2s; }
        pre:hover .copy-btn { opacity: 1; }
        .preview-component.hidden { display: none; }
        .preview-component.reward-highlight { background-color: rgba(34, 197, 94, 0.1); border-left: 4px solid #22c55e; padding-left: 8px;}
        .preview-component.cost-highlight { background-color: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; padding-left: 8px; }
        .slider::-webkit-slider-thumb { background: var(--accent-color); box-shadow: 0 0 0 3px var(--bg-secondary), 0 0 0 4px var(--accent-color); }
        #back-to-top { transition: opacity 0.3s, transform 0.3s; }

        /* Landing page background animation */
        @keyframes gradient-animation {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
        }
        .animated-gradient {
            background: linear-gradient(270deg, #f3e8ff, #e0e7ff, #f0f9ff);
            background-size: 600% 600%;
            animation: gradient-animation 16s ease infinite;
        }
        .dark .animated-gradient {
             background: linear-gradient(270deg, #1e1b4b, #1e293b, #0c4a6e);
             background-size: 600% 600%;
             animation: gradient-animation 16s ease infinite;
        }

    </style>
</head>
<body>
    <!-- Revamped Landing Page -->
    <section id="home-landing" class="min-h-screen flex flex-col justify-center items-center p-4 animated-gradient">
        <div class="max-w-4xl text-center">
            <h1 class="text-5xl md:text-7xl font-extrabold text-indigo-700 dark:text-indigo-400 mb-6" style="animation: fadeInUp 0.8s ease-out both;">
                智能锅炉强化学习优化平台
            </h1>
            <p class="text-lg text-slate-600 dark:text-slate-300 mb-10 max-w-3xl mx-auto" style="animation: fadeInUp 0.8s ease-out 0.2s both;">
                融合深度强化学习与工业机理，驱动传统能源的智能化变革。我们提供从理论学习、仿真实验到部署策略的全链路解决方案。
            </p>
            <button id="start-experience-btn" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-indigo-700 hover:shadow-xl transform hover:-translate-y-1 transition-all text-xl" style="animation: fadeInUp 0.8s ease-out 0.4s both;">
                <i class="fa-solid fa-rocket mr-2"></i>开启学习之旅
            </button>
        </div>
        <div class="max-w-6xl mx-auto mt-20 grid md:grid-cols-3 gap-8 px-4" style="animation: fadeInUp 0.8s ease-out 0.6s both;">
            <div class="card p-6 text-left hover:-translate-y-2">
                <i class="fa-solid fa-book-open text-3xl text-indigo-500 mb-4"></i>
                <h3 class="text-xl font-bold mt-0 mb-2">系统化理论</h3>
                <p class="text-themed-secondary text-sm">从MDP到PPO/SAC，层层递进，构建坚实的理论基础。</p>
            </div>
            <div class="card p-6 text-left hover:-translate-y-2">
                <i class="fa-solid fa-flask-vial text-3xl text-indigo-500 mb-4"></i>
                <h3 class="text-xl font-bold mt-0 mb-2">交互式实验</h3>
                <p class="text-themed-secondary text-sm">在多个可视化沙箱中，亲手调节参数，直观感受算法核心。</p>
            </div>
            <div class="card p-6 text-left hover:-translate-y-2">
                <i class="fa-solid fa-cogs text-3xl text-indigo-500 mb-4"></i>
                <h3 class="text-xl font-bold mt-0 mb-2">工程化实践</h3>
                <p class="text-themed-secondary text-sm">学习从数字孪生到三阶段安全部署的完整工业落地流程。</p>
            </div>
        </div>
        <footer class="text-center text-slate-500 dark:text-slate-400 text-sm py-6 w-full absolute bottom-0 border-t border-slate-200 dark:border-slate-700">
            &copy; 2025 智能锅炉优化平台 | 技术支持：HGC团队 | 
            <i class="fa-solid fa-eye"></i> 访问量: <span id="visitor-count">加载中...</span>
        </footer>
    </section>

    <!-- Main App Interface -->
    <div id="main-app" class="hidden">
        <header class="bg-themed-secondary/80 dark:bg-themed-secondary/80 backdrop-blur-sm sticky top-0 z-40 w-full border-b border-themed">
            <div class="container mx-auto flex items-center justify-between p-4">
                <div class="flex items-center gap-3 cursor-pointer" id="main-logo">
                    <img src="image/seu-logo.png" alt="东南大学logo" class="h-10 w-10 rounded-full bg-white p-0.5" onerror="this.onerror=null;this.src='https://placehold.co/64x64/ffffff/000000?text=SEU';" />
                    <h1 class="text-xl font-bold text-indigo-500 dark:text-indigo-400 hidden sm:block">RL锅炉优化平台</h1>
                </div>
                <div class="relative hidden md:block" id="search-container">
                    <i class="fa-solid fa-search absolute left-3 top-1/2 -translate-y-1/2 text-themed-secondary"></i>
                    <input type="text" id="search-input" placeholder="搜索章节..." class="w-64 bg-themed-muted border border-themed rounded-lg py-1.5 pl-9 pr-4 focus:outline-none focus:ring-2 focus:ring-accent-color">
                    <div id="search-results" class="hidden absolute top-full left-0 mt-2 w-full bg-themed-secondary rounded-lg shadow-xl border border-themed p-2 z-50"></div>
                </div>
                <nav class="hidden md:flex items-center gap-2" id="desktop-nav"></nav>
                <div class="flex items-center gap-4">
                    <div id="auth-section"></div>
                    <button id="theme-toggle-btn" class="w-10 h-10 flex items-center justify-center rounded-lg hover:bg-themed-muted transition-colors">
                        <i id="theme-icon" class="fa-solid fa-moon"></i>
                    </button>
                    <button id="mobile-menu-btn" class="md:hidden w-10 h-10 flex items-center justify-center rounded-lg hover:bg-themed-muted transition-colors">
                        <i class="fa-solid fa-bars"></i>
                    </button>
                </div>
            </div>
            <div id="mobile-menu" class="hidden md:hidden border-t border-themed p-4"></div>
        </header>
        
        <main class="container mx-auto p-4 md:p-8">
            <div id="breadcrumb" class="mb-4 text-sm text-themed-secondary"></div>
            <div id="content-container"></div>
        </main>
    </div>

    <!-- Modals -->
    <div id="auth-modal" class="modal-backdrop"></div>
    
    <!-- Back to Top Button -->
    <button id="back-to-top" class="fixed bottom-5 right-5 w-12 h-12 rounded-full bg-indigo-600 text-white shadow-lg flex items-center justify-center opacity-0 transform translate-y-4 pointer-events-none">
        <i class="fa-solid fa-arrow-up"></i>
    </button>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, runTransaction, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- App State ---
        const state = { currentUser: null, userProgress: [], currentView: '', activeAnimationFrames: {} };

        // --- Firebase Configuration and Initialization ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'rl-boiler-app-pro';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        let app, auth, db;

        if (firebaseConfig) {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                setupAuthListener();
                incrementAndShowVisitorCount();
            } catch (e) { console.error("Firebase initialization failed:", e); }
        } else {
            console.warn("Firebase config not found. Some features like user progress and visitor count will be disabled.");
        }

        // --- Authentication & User Progress ---
        function setupAuthListener() {
            onAuthStateChanged(auth, async user => {
                if (user) {
                    state.currentUser = { uid: user.uid, email: user.email };
                    await fetchUserProgress(user.uid);
                } else {
                    state.currentUser = null;
                    state.userProgress = [];
                }
                renderAuthSection();
                renderNav();
            });
        }
        
        async function fetchUserProgress(userId) {
            if (!db) return;
            const progressRef = doc(db, `artifacts/${appId}/users/${userId}/progress`, 'main');
            const docSnap = await getDoc(progressRef);
            state.userProgress = docSnap.exists() ? docSnap.data().completedChapters || [] : [];
        }

        async function markChapterAsCompleted(chapterId) {
            if (!state.currentUser || state.userProgress.includes(chapterId) || !db) return;
            if (chapterId.startsWith('quiz')) return; // Do not mark quizzes as completed
            state.userProgress.push(chapterId);
            renderNav();
            const progressRef = doc(db, `artifacts/${appId}/users/${state.currentUser.uid}/progress`, 'main');
            try {
                await setDoc(progressRef, { completedChapters: arrayUnion(chapterId) }, { merge: true });
            } catch (error) { console.error("Error updating progress:", error); }
        }

        // --- Visitor Counter ---
        async function incrementAndShowVisitorCount() {
            const visitorCountEl = document.getElementById('visitor-count');
            if (!db) {
                if(visitorCountEl) visitorCountEl.textContent = 'N/A';
                return;
            }
            const counterRef = doc(db, `artifacts/${appId}/public/data/analytics`, 'page_views');
            try {
                await runTransaction(db, async (transaction) => {
                    const counterDoc = await transaction.get(counterRef);
                    const newCount = (counterDoc.data()?.count || 0) + 1;
                    transaction.set(counterRef, { count: newCount });
                });
                const finalDoc = await getDoc(counterRef);
                if (finalDoc.exists() && visitorCountEl) visitorCountEl.textContent = finalDoc.data().count;
            } catch (e) { 
                console.error("Failed to update visitor count:", e); 
                if(visitorCountEl) visitorCountEl.textContent = 'Error';
            }
        }

        // --- UI Element Selectors ---
        const contentContainer = document.getElementById('content-container');
        const desktopNav = document.getElementById('desktop-nav');
        const mobileMenu = document.getElementById('mobile-menu');
        const authSection = document.getElementById('auth-section');
        const authModalContainer = document.getElementById('auth-modal');
        const backToTopBtn = document.getElementById('back-to-top');
        const breadcrumb = document.getElementById('breadcrumb');
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');

        // --- Navigation Structure ---
        const navStructure = [
            { title: '基础篇', chapters: ['chapter1', 'chapter2'] },
            { title: '核心算法', chapters: ['chapter3', 'chapter4', 'chapter5', 'chapter6', 'quiz1'] },
            { title: '实践篇', chapters: ['chapter7', 'chapter8', 'chapter9'] },
            { title: '部署与未来', chapters: ['chapter10', 'chapter11', 'chapter12'] },
            { title: '关于', chapters: ['glossary', 'team', 'resources'] }
        ];
        const chapterDetails = {
            'chapter1': '锅炉系统原理', 'chapter2': '强化学习世界观', 'chapter3': '从RL到深度RL',
            'chapter4': '演员-评论家架构', 'chapter5': 'PPO算法详解', 'chapter6': 'SAC算法详解',
            'quiz1': '阶段小测 (核心算法)',
            'chapter7': 'CMDP构建实验室', 'chapter8': '构建数字孪生', 'chapter9': '训练实验与调试',
            'chapter10': '三阶段安全部署', 'chapter11': '总结与未来', 'chapter12': '高级主题-离线RL',
            'glossary': '关键术语表',
            'team': '团队介绍', 'resources': '关键资源'
        };

        // --- UI Rendering Functions ---
        function renderNav() {
            const navHtml = navStructure.map(group => `
                <div class="dropdown relative">
                    <button class="nav-dropdown-btn p-2 rounded-lg hover:bg-themed-muted transition-colors flex items-center gap-1" data-group="${group.title}">${group.title} <i class="fa-solid fa-chevron-down text-xs"></i></button>
                    <div class="dropdown-menu hidden absolute top-full left-0 mt-2 w-64 bg-themed-secondary rounded-lg shadow-xl border border-themed p-2 z-50">
                        ${group.chapters.map(id => `<a href="#${id}" data-view="${id}" class="nav-link flex items-center p-2 rounded-md text-sm ${state.userProgress.includes(id) ? 'nav-link-completed' : ''}">${chapterDetails[id]}</a>`).join('')}
                    </div>
                </div>`).join('');
            desktopNav.innerHTML = navHtml;
            mobileMenu.innerHTML = navStructure.flatMap(group => 
                [`<div class="px-2 py-1 text-sm font-semibold text-themed-secondary">${group.title}</div>`]
                .concat(group.chapters.map(id => `<a href="#${id}" data-view="${id}" class="nav-link block p-2 rounded-md text-sm ${state.userProgress.includes(id) ? 'nav-link-completed' : ''}">${chapterDetails[id]}</a>`))
            ).join('');
            updateNavActiveState();
        }

        function renderAuthSection() {
            authSection.innerHTML = state.currentUser ? `
                <div class="dropdown relative">
                    <button class="nav-dropdown-btn w-10 h-10 flex items-center justify-center rounded-full bg-indigo-100 dark:bg-indigo-900 text-indigo-600 dark:text-indigo-300 font-semibold">
                        ${state.currentUser.email ? state.currentUser.email[0].toUpperCase() : 'A'}
                    </button>
                    <div class="dropdown-menu hidden absolute top-full right-0 mt-2 w-48 bg-themed-secondary rounded-lg shadow-xl border border-themed p-2 z-50">
                        <div class="px-2 py-1 text-xs text-themed-secondary truncate">${state.currentUser.email || '匿名用户'}</div>
                        <div class="my-1 border-t border-themed"></div>
                        <button id="logout-btn" class="w-full text-left p-2 rounded-md text-sm hover:bg-themed-muted">退出登录</button>
                    </div>
                </div>` : `
                <div class="flex items-center gap-2">
                    <button id="login-btn" class="px-3 py-1.5 text-sm rounded-lg hover:bg-themed-muted transition-colors">登录</button>
                    <button id="register-btn" class="px-3 py-1.5 text-sm rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition-colors">注册</button>
                </div>`;
        }
        
        function showAuthModal(isLogin = true) {
            authModalContainer.innerHTML = `
                <div class="modal-content">
                    <h3 class="text-xl font-bold text-indigo-500 dark:text-indigo-400 mb-2">${isLogin ? '登录平台' : '创建账户'}</h3>
                    <p class="text-themed-secondary mb-6 text-sm">开始您的智能优化学习之旅。</p>
                    <div id="auth-error" class="hidden p-3 mb-4 text-sm text-red-700 bg-red-100 rounded-lg dark:bg-red-200 dark:text-red-800"></div>
                    <form id="auth-form">
                        <div class="space-y-4">
                            <div><label for="auth-email" class="block text-sm font-medium text-themed-secondary">邮箱</label><input type="email" id="auth-email" required class="mt-1 block w-full bg-themed-muted border border-themed rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></div>
                            <div><label for="auth-password" class="block text-sm font-medium text-themed-secondary">密码</label><input type="password" id="auth-password" required class="mt-1 block w-full bg-themed-muted border border-themed rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></div>
                        </div>
                        <div class="mt-6 flex items-center justify-between">
                            <button type="button" id="auth-switch-btn" class="text-sm text-indigo-600 hover:underline">${isLogin ? '没有账户？去注册' : '已有账户？去登录'}</button>
                            <button type="submit" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">${isLogin ? '登录' : '注册'}</button>
                        </div>
                    </form>
                </div>`;
            authModalContainer.classList.add('visible');
        }

        // --- Event Listeners & App Flow ---
        document.body.addEventListener('click', e => {
            if (e.target.id === 'logout-btn') signOut(auth);
            if (e.target.id === 'login-btn') showAuthModal(true);
            if (e.target.id === 'register-btn') showAuthModal(false);
            if (e.target.id === 'auth-switch-btn') showAuthModal(e.target.textContent.includes('注册'));
            
            if (e.target.closest('.modal-backdrop') && !e.target.closest('.modal-content')) e.target.closest('.modal-backdrop').classList.remove('visible');

            const navLink = e.target.closest('.nav-link');
            if (navLink) {
                e.preventDefault();
                navigateTo(navLink.dataset.view);
                mobileMenu.classList.add('hidden');
                document.querySelectorAll('.dropdown').forEach(d => d.classList.remove('open'));
                searchResults.classList.add('hidden');
                searchInput.value = '';
            }
            
            const dropdownBtn = e.target.closest('.nav-dropdown-btn');
            if (dropdownBtn) {
                const parentDropdown = dropdownBtn.closest('.dropdown');
                const wasOpen = parentDropdown.classList.contains('open');
                document.querySelectorAll('.dropdown').forEach(d => d.classList.remove('open'));
                if (!wasOpen) parentDropdown.classList.add('open');
            } else if (!e.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown').forEach(d => d.classList.remove('open'));
            }

            if (e.target.closest('.copy-btn')) {
                const pre = e.target.closest('pre');
                const code = pre.querySelector('code').innerText;
                navigator.clipboard.writeText(code).then(() => {
                    e.target.innerHTML = '<i class="fa-solid fa-check"></i> 已复制!';
                    setTimeout(() => { e.target.innerHTML = '<i class="fa-solid fa-copy"></i> 复制'; }, 2000);
                });
            }
        });

        authModalContainer.addEventListener('submit', async e => {
            if (e.target.id !== 'auth-form') return;
            e.preventDefault();
            const email = e.target.querySelector('#auth-email').value;
            const password = e.target.querySelector('#auth-password').value;
            const isLogin = e.target.querySelector('#auth-switch-btn').textContent.includes('注册');
            const errorDiv = e.target.querySelector('#auth-error');
            try {
                if (isLogin) await signInWithEmailAndPassword(auth, email, password);
                else await createUserWithEmailAndPassword(auth, email, password);
                authModalContainer.classList.remove('visible');
            } catch (error) {
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('hidden');
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const homeLanding = document.getElementById('home-landing');
            const mainApp = document.getElementById('main-app');
            const startBtn = document.getElementById('start-experience-btn');
            const mainLogo = document.getElementById('main-logo');
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const themeIcon = document.getElementById('theme-icon');

            renderNav();
            renderAuthSection();

            startBtn.addEventListener('click', () => {
                homeLanding.style.display = 'none';
                mainApp.style.display = 'block';
                navigateTo(window.location.hash.substring(1) || 'chapter1');
            });
            mainLogo.addEventListener('click', () => {
                mainApp.style.display = 'none';
                homeLanding.style.display = 'flex';
                cleanupAnimations();
                state.currentView = 'home';
                window.history.pushState({view: 'home'}, '', '#');
            });
            mobileMenuBtn.addEventListener('click', () => mobileMenu.classList.toggle('hidden'));

            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                    themeIcon.classList.replace('fa-moon', 'fa-sun');
                } else {
                    document.documentElement.classList.remove('dark');
                    themeIcon.classList.replace('fa-sun', 'fa-moon');
                }
                if(state.currentView) initializeInteractiveModules(state.currentView);
            }
            themeToggleBtn.addEventListener('click', () => {
                const newTheme = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme);
                applyTheme(newTheme);
            });
            applyTheme(localStorage.getItem('theme') || 'light');

            const initialHash = window.location.hash.substring(1);
            if (initialHash && chapterDetails[initialHash]) {
                startBtn.click();
            }
            
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    backToTopBtn.classList.remove('opacity-0', 'translate-y-4', 'pointer-events-none');
                } else {
                    backToTopBtn.classList.add('opacity-0', 'translate-y-4', 'pointer-events-none');
                }
            });
            backToTopBtn.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });

            searchInput.addEventListener('input', () => {
                const query = searchInput.value.toLowerCase().trim();
                if (!query) {
                    searchResults.classList.add('hidden');
                    return;
                }
                const results = Object.entries(chapterDetails).filter(([id, title]) => title.toLowerCase().includes(query) || id.toLowerCase().includes(query));
                if (results.length > 0) {
                    searchResults.innerHTML = results.map(([id, title]) => 
                        `<a href="#${id}" data-view="${id}" class="nav-link block p-2 rounded-md text-sm hover:bg-themed-muted">${title}</a>`
                    ).join('');
                    searchResults.classList.remove('hidden');
                } else {
                    searchResults.innerHTML = `<div class="p-2 text-sm text-themed-secondary">无匹配结果</div>`;
                    searchResults.classList.remove('hidden');
                }
            });
            document.addEventListener('click', (e) => {
                if (!document.getElementById('search-container').contains(e.target)) {
                    searchResults.classList.add('hidden');
                }
            });
        });

        function cleanupAnimations() {
            Object.values(state.activeAnimationFrames).forEach(id => { if (id) cancelAnimationFrame(id); });
            state.activeAnimationFrames = {};
            if(window.acAnimationTimeoutId) clearTimeout(window.acAnimationTimeoutId);
            if(window.rlSimulationIntervalId) clearInterval(window.rlSimulationIntervalId);
            if(window.bellmanInterval) clearInterval(window.bellmanInterval);
            if(window.rlAgentIntervalId) clearInterval(window.rlAgentIntervalId);
        }

        function navigateTo(viewId) {
            if (!viewId) return;
            cleanupAnimations();
            state.currentView = viewId;
            contentContainer.innerHTML = chapterContents[viewId] || `<div class="card p-8"><h2>内容即将上线</h2><p>我们正在努力准备这一章节的内容，敬请期待！</p></div>`;
            updateNavActiveState();
            updateBreadcrumb(viewId);
            addCopyToCodeBlocks();
            initializeInteractiveModules(viewId);
            markChapterAsCompleted(viewId);
            if(window.location.hash !== `#${viewId}`) window.history.pushState({view: viewId}, '', `#${viewId}`);
            window.scrollTo(0, 0);
        }

        function updateBreadcrumb(viewId) {
            const chapterTitle = chapterDetails[viewId];
            const group = navStructure.find(g => g.chapters.includes(viewId));
            if (chapterTitle && group) {
                breadcrumb.innerHTML = `<a href="#" data-view="${group.chapters[0]}" class="nav-link hover:text-accent-color">${group.title}</a> &raquo; <span>${chapterTitle}</span>`;
            } else {
                breadcrumb.innerHTML = '';
            }
        }

        function addCopyToCodeBlocks() {
            const pres = contentContainer.querySelectorAll('pre');
            pres.forEach(pre => {
                const btn = document.createElement('button');
                btn.className = 'copy-btn';
                btn.innerHTML = '<i class="fa-solid fa-copy"></i> 复制';
                pre.appendChild(btn);
            });
        }
        
        function updateNavActiveState() {
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.toggle('active', link.dataset.view === state.currentView);
            });
            document.querySelectorAll('.nav-dropdown-btn').forEach(btn => btn.classList.remove('active'));
            const activeLink = document.querySelector(`.nav-link[data-view="${state.currentView}"]`);
            if (activeLink) {
                const parentDropdownBtn = activeLink.closest('.dropdown')?.querySelector('.nav-dropdown-btn');
                if (parentDropdownBtn) parentDropdownBtn.classList.add('active');
            }
        }
        
        function initializeInteractiveModules(viewId) {
            window.activeAnimationFrames = state.activeAnimationFrames;
            switch(viewId) {
                case 'chapter1': initChapter1(); break;
                case 'chapter2': initChapter2(); break;
                case 'chapter4': initActorCriticViz(); break;
                case 'chapter5': initPpoCanvas(); break;
                case 'chapter6': initSacCanvas(); break;
                case 'quiz1': initQuiz(); break;
                case 'chapter7': initCmdpLab(); break;
                case 'chapter8': initSimRealCanvas(); break; 
                case 'chapter9': initRlTrainingLab(); break;
                case 'chapter10': selectStep(1); break;
                case 'chapter12': renderOfflineRLDiagram(); break;
            }
            if (window.MathJax) MathJax.typesetPromise();
        }

        // --- All Chapter Content and Interactive Logic ---
        const chapterContents = {
            'chapter1': `<h2>第1章: 锅炉系统原理</h2><p class="text-lg text-themed-secondary mb-6">在应用任何高级算法之前，必须对被控对象——锅炉，有深刻的物理和工程理解。本章将带您深入了解锅炉背后的核心矛盾，并通过一个进化版的互动沙箱，让您亲手感受在动态工况下控制锅炉的挑战。</p><div class="card p-6 mb-6"><h3 class="text-xl font-bold">系统组件与热力循环</h3><p class="text-themed-secondary mb-4">锅炉并非孤立设备，而是发电厂热力系统的核心。它通过燃烧燃料（如煤粉）产生高温高压蒸汽，驱动汽轮机做功发电。这个过程在热力学上遵循经典的**朗肯循环**。</p><div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center"><div id="boiler-diagram-container" class="p-2 bg-themed-secondary rounded-lg shadow-inner"></div><div id="rankine-diagram-container" class="p-2 bg-themed-secondary rounded-lg shadow-inner"></div></div></div><div class="card p-6"><h3 class="text-xl font-bold">动态工况锅炉沙箱</h3><p class="text-themed-secondary mb-6">您的任务是在不同负荷下，通过调节控制变量（动作），使各项指标（状态）尽可能接近目标值，体验多目标优化的核心挑战。</p><div class="grid grid-cols-1 lg:grid-cols-5 gap-6"><div class="lg:col-span-2 bg-themed-muted p-6 rounded-lg"><h4 class="font-bold text-lg mb-4">🕹️ 控制与工况面板</h4><div class="space-y-6"><div><label for="load-slider" class="font-medium flex justify-between">锅炉负荷 (扰动): <span id="load-value" class="font-bold text-red-500">75</span>%</label><input type="range" id="load-slider" min="50" max="100" value="75" class="slider w-full"></div><div class="border-t border-themed pt-4"><label for="air-total-slider" class="font-medium flex justify-between">总风量 (动作): <span id="air-total-value">75</span>%</label><input type="range" id="air-total-slider" min="50" max="100" value="75" class="slider w-full"></div><div><label for="burner-tilt-slider" class="font-medium flex justify-between">燃烧器摆角 (动作): <span id="burner-tilt-value">0</span>°</label><input type="range" id="burner-tilt-slider" min="-15" max="15" value="0" class="slider w-full"></div><div><label for="o2-dist-slider" class="font-medium flex justify-between">燃尽风(OFA)占比 (动作): <span id="o2-dist-value">30</span>%</label><input type="range" id="o2-dist-slider" min="10" max="50" value="30" class="slider w-full"></div></div></div><div class="lg:col-span-3"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="p-4 rounded-lg bg-slate-700 flex flex-col items-center justify-center min-h-[300px]"><h4 class="font-bold text-lg mb-2 text-white">🔥 炉膛火焰</h4><div id="boiler-visual-container" class="w-48 h-64 bg-slate-800 rounded-t-lg relative overflow-hidden"><div id="flame-visual" class="flame-visual"></div></div></div><div class="p-4 rounded-lg bg-themed-muted flex flex-col justify-between"><h4 class="font-bold text-lg mb-4">📈 关键指标</h4><div class="space-y-4"><div><label class="font-medium flex justify-between">氮氧化物 (NOx) <span class="text-sm text-themed-secondary">目标: &lt;50</span></label><div class="w-full bg-slate-200 dark:bg-slate-600 rounded-full h-4"><div id="nox-meter-fill" class="bg-red-500 h-4 rounded-full transition-all duration-300"></div></div></div><div><label class="font-medium flex justify-between">一氧化碳 (CO) <span class="text-sm text-themed-secondary">目标: &lt;40</span></label><div class="w-full bg-slate-200 dark:bg-slate-600 rounded-full h-4"><div id="co-meter-fill" class="bg-amber-500 h-4 rounded-full transition-all duration-300"></div></div></div><div><label class="font-medium flex justify-between">锅炉热效率 <span class="text-sm text-themed-secondary">目标: &gt;93%</span></label><div class="text-right"><span id="efficiency-value" class="text-2xl font-bold text-green-600">92.50</span> %</div></div></div></div></div></div></div></div><div class="card p-6 mt-6"><h3 class="text-xl font-bold">核心矛盾：帕累托最优前沿</h3><p class="text-themed-secondary mb-6">锅炉优化的本质是在多个相互冲突的目标之间寻找最佳平衡点。例如，降低NOx排放通常需要降低燃烧温度，但这可能导致CO增加和热效率下降。这个最佳平衡点的集合被称为"帕累托最优前沿"。RL智能体的任务，就是找到并维持在这一前沿上的最优工作点。</p><div class="p-4 bg-themed-muted rounded-lg"><canvas id="pareto-chart" height="120"></canvas></div></div>`,
            'chapter2': `<h2>第2章: 强化学习世界观</h2><p class="text-lg text-themed-secondary mb-6">强化学习(RL)是一种通过"试错"来学习的机器学习范式。智能体(Agent)在与环境(Environment)的交互中，根据获得的奖励(Reward)或惩罚来学习如何选择动作(Action)，以最大化长期累积奖励。</p><div class="card p-6 mb-6"><h3 class="text-xl font-bold">2.1 马尔可夫决策过程 (MDP)</h3><p class="text-themed-secondary mb-4">RL问题通常被数学化地描述为马尔可夫决策过程 (MDP)，一个由五元组构成的模型： $(S, A, P, R, \\gamma)$</p><ul class="list-disc list-inside space-y-2 text-themed-secondary bg-themed-muted p-4 rounded-lg"><li><b>S (State)</b>: 状态集合。在锅炉中，这可以是包含主蒸汽压力、温度、含氧量等的多维向量。</li><li><b>A (Action)</b>: 动作集合。例如，调节给煤量、总风量、燃烧器摆角等。</li><li><b>P (Transition Probability)</b>: 状态转移概率 $P(s'|s,a)$。描述了在状态 $s$ 执行动作 $a$ 后，转移到状态 $s'$ 的概率。在现实工业中，这个函数是未知且复杂的。</li><li><b>R (Reward Function)</b>: 奖励函数 $R(s,a,s')$。这是我们定义RL目标的核心，例如，高效发电是正奖励，NOx超标是负奖励。</li><li><b>$\\gamma$ (Discount Factor)</b>: 折扣因子，取值在[0, 1]之间，用于平衡短期奖励和长期奖励的重要性。</li></ul></div><div class="card p-6 mb-6"><h3 class="text-xl font-bold">2.2 贝尔曼方程：价值学习的核心</h3><p class="text-themed-secondary mb-4">RL的目标是找到一个最优策略 $\\pi^*(a|s)$，它能告诉我们在任何状态下应该采取什么动作来最大化期望回报。为了评估一个策略有多好，我们定义了状态价值函数 $V^\\pi(s)$，它代表从状态 $s$ 开始，遵循策略 $\\pi$ 所能获得的期望回报。它遵循著名的贝尔曼期望方程：</p><div class="p-4 my-2 bg-themed-muted rounded text-center text-lg">$$V^\\pi(s) = \\mathbb{E}_{\\pi} [R_{t+1} + \\gamma V^\\pi(S_{t+1}) | S_t=s]$$</div><p class="text-themed-secondary mt-4">这个公式是所有价值学习算法的基石，它将当前状态的价值与后续状态的价值联系在了一起。</p></div><div class="card p-6 mb-6"><h3 class="text-xl font-bold">2.3 RL算法全景图</h3><p class="text-themed-secondary mb-4">RL算法种类繁多，但可以根据几个关键维度进行划分。下图为您提供了一个清晰的分类框架，帮助您理解我们后续将要介绍的PPO、SAC等算法在整个版图中的位置。</p><div id="rl-taxonomy-container" class="p-4 bg-themed-muted rounded-lg flex justify-center"></div></div><div class="card p-6 mb-6"><h3 class="text-xl font-bold">2.4 交互式动态规划求解器 (升级版)</h3><p class="text-slate-600 dark:text-slate-300 mb-4">在锅炉燃烧优化中，动态规划可用于求解最优控制策略。例如，我们可以将锅炉的燃烧状态（如温度、压力、污染物浓度）定义为状态空间，将调节风门开度、燃料供给量等操作定义为动作空间，将燃烧效率最大化和污染物排放最小化定义为奖励函数。</p>
                        <p class="text-slate-600 dark:text-slate-300 mb-4">动态规划(DP)是解决已知模型（即 $P$ 和 $R$ 都已知）MDP的基础方法。虽然在锅炉优化中我们无法直接使用DP，但理解它的工作原理是理解更高级算法的基石。下面，您可以亲手操作或观看经典的DP算法：<b>价值迭代</b>和<b>策略迭代</b>，是如何找到最优策略的。</p>
                        <div class="flex flex-col md:flex-row gap-6 items-start">
                            <div class="flex-shrink-0">
                                <canvas id="bellman-canvas" width="400" height="400" class="border rounded-lg bg-white dark:bg-slate-800 shadow-inner"></canvas>
                                <div id="bellman-step-info" class="mt-2 text-sm p-2 bg-yellow-50 dark:bg-yellow-900/30 rounded-lg min-h-[60px]"></div>
                            </div>
                            <div class="flex-grow space-y-4">
                                <div class="grid grid-cols-2 gap-2">
                                    <button id="iterate-bellman-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors"><i class="fa-solid fa-shoe-prints"></i> 迭代一步</button>
                                    <button id="solve-bellman-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors"><i class="fa-solid fa-robot"></i> 自动求解</button>
                                </div>
                                <button id="reset-bellman-btn" class="w-full bg-slate-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-600 transition-colors"><i class="fa-solid fa-arrow-rotate-left"></i> 重置</button>
                                 <div class="p-3 bg-themed-muted rounded-lg">
                                     <label for="dp-method-select" class="text-sm font-bold text-themed-secondary">选择算法:</label>
                                     <select id="dp-method-select" class="w-full p-2 rounded border-gray-300 dark:bg-slate-700 dark:border-slate-600 mt-1">
                                         <option value="vi">价值迭代 (Value Iteration)</option>
                                         <option value="pi">策略迭代 (Policy Iteration)</option>
                                     </select>
                                 </div>
                                <div class="text-sm p-4 bg-slate-50 dark:bg-slate-800 rounded-lg">
                                    <p><strong>迭代次数:</strong> <span id="bellman-iteration-count">0</span></p>
                                    <p><strong>当前阶段:</strong> <span id="pi-phase-info">--</span></p>
                                    <p><strong>折扣因子 $\\gamma$:</strong> 0.9</p>
                                    <div id="bellman-update-info" class="text-center font-mono h-12 mt-2 p-2 bg-slate-100 dark:bg-slate-700 rounded flex items-center justify-center">请开始迭代...</div>
                                </div>
                            </div>
                        </div>
                    </div>`,
            'chapter3': `<h2>第3章: 从RL到深度RL</h2><p class="text-lg text-themed-secondary mb-6">经典RL方法使用表格（如Q-Table）存储每个状态或状态-动作对的价值。但这在状态空间巨大时（例如，锅炉状态由多个连续变量构成）会面临"维度灾难"，表格会变得无限大。深度学习通过使用神经网络作为强大的函数逼近器，催生了深度强化学习（DRL），彻底改变了这一领域。</p><div class="card p-6 mb-6"><h3 class="text-xl font-bold">函数逼近的必要性</h3><p class="text-themed-secondary mb-4">锅炉的状态由主蒸汽压力、温度、壁温、氧量等多个连续变量描述，理论上存在无限个状态。我们不可能用一张表来存储所有状态的价值。神经网络（NN）的强大泛化能力使其能够从有限的经验中学习，对未曾见过的状态也能做出合理的价值估计。我们用一个带参数 $\\theta$ 的网络 $Q(s, a; \\theta)$ 来近似真实的Q值。</p></div><div class="card p-6"><h3 class="text-xl font-bold">深度Q网络 (DQN)</h3><p class="text-themed-secondary mb-4">DQN是DRL的开创性工作，它成功地将深度卷积网络与Q-Learning结合，在雅达利游戏上达到了超越人类的水平。DQN引入了两个关键技术来解决使用非线性函数逼近器（神经网络）时训练不稳定的问题：</p><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="p-4 bg-blue-500/10 rounded-lg"><h4 class="font-bold text-blue-600 dark:text-blue-400">经验回放 (Experience Replay)</h4><p class="text-sm mt-2">智能体与环境交互的经验元组 $(s_t, a_t, r_t, s_{t+1})$ 被存储在一个固定大小的"回放池"（Replay Buffer）中。训练时，不再使用刚产生的单个经验，而是从池中随机采样一个小批量（mini-batch）的数据进行更新。这打破了经验数据之间的时间相关性，使样本更接近独立同分布，并极大地提高了数据利用效率。</p></div><div class="p-4 bg-green-500/10 rounded-lg"><h4 class="font-bold text-green-600 dark:text-green-400">目标网络 (Target Network)</h4><p class="text-sm mt-2">使用两个结构相同但参数不同的Q网络：一个是在线网络（Online Network, 参数 $\\theta$），用于选择动作和在每步都更新；另一个是目标网络（Target Network, 参数 $\\theta^-$），用于计算TD目标。目标网络的参数不会每步都更新，而是定期从在线网络复制过来。这使得TD目标在一段时间内保持稳定，避免了"追逐自己尾巴"的问题。</p></div></div><div class="mt-6 p-4 bg-themed-muted rounded-lg"><h4 class="font-bold text-lg mb-2">DQN的损失函数</h4><p class="text-themed-secondary mb-2">DQN的更新目标是让在线网络预测的Q值 $Q(s, a; \\theta)$ 逼近"TD目标" $y_t$。这个目标是使用旧的目标网络计算的：</p><div class="p-2 my-2 bg-themed-secondary rounded text-center text-md">$$ y_t = r_t + \\gamma \\max_{a'} Q(s_{t+1}, a'; \\theta^-) $$</div><p class="text-themed-secondary mt-2">因此，损失函数是一个简单的均方误差（MSE）：</p><div class="p-2 my-2 bg-themed-secondary rounded text-center text-md">$$ L(\\theta) = \\mathbb{E}_{(s,a,r,s') \\sim D} \\left[ (y_t - Q(s, a; \\theta))^2 \\right] $$</div></div></div>`,
            'chapter4': `<h2>第4章: 演员-评论家架构</h2><p class="text-lg text-themed-secondary mb-6">演员-评论家（Actor-Critic, AC）方法是现代RL算法的支柱，它结合了策略学习（Policy-Based）和价值学习（Value-Based）的优点，能够处理连续动作空间问题，并通常具有更稳定的收敛性。</p><div class="card p-6 mb-6"><h3 class="text-xl font-bold">演员与评论家的角色分工</h3><ul class="list-disc list-inside space-y-2 text-themed-secondary"><li><b>演员 (Actor)</b>: 演员是一个参数化的策略 $\\pi_\\theta(a|s)$，负责根据当前状态 $s$ 输出一个动作（或动作的概率分布）。它的目标是学习一个好的策略，所以被称为"策略网络"。</li><li><b>评论家 (Critic)</b>: 评论家是一个参数化的价值函数 $Q_\\phi(s,a)$ 或 $V_\\phi(s)$，负责评价演员选择的动作有多好。它不产出动作，只为演员提供反馈信号，所以被称为"价值网络"。</li></ul><p class="text-themed-secondary mt-4">两者协同工作：演员在台上表演（选择动作），评论家在台下打分（评估动作好坏）。演员根据评论家的分数来调整自己的表演策略，力求获得更高的分数。</p></div><div class="card p-6"><h3 class="text-xl font-bold">动态演示：信息与优势函数流动过程</h3><p class="text-themed-secondary mb-4">点击播放下面的动画，观察一个典型的AC更新周期。评论家会计算出**优势函数 $A(s,a) = Q(s,a) - V(s)$**，这个信号是指导演员更新策略的核心依据。如果优势为正，说明这个动作比平均水平要好，演员就增加选择这个动作的概率；反之则降低概率。</p><div class="text-center mb-4"><button id="play-ac-viz" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">▶️ 播放流程</button></div><div id="ac-viz-explanation" class="text-center font-semibold h-10 mb-2"></div><div id="ac-diagram-container" class="flex justify-center"></div></div>`,
            'chapter5': `<h2>第5章: PPO算法详解</h2><p class="text-lg text-themed-secondary mb-6">近端策略优化（PPO）是目前应用最广泛的RL算法之一，由OpenAI提出，以其卓越的稳定性和性能而闻名。其核心思想是：在更新策略时，步子不能迈得太大，避免新旧策略差异过大导致训练崩溃。</p><div class="card p-6"><h3 class="text-xl font-bold">交互式理解：可调节的信任域裁剪</h3><p class="text-themed-secondary mb-4">令 $r_t(\\theta) = \\frac{\\pi_\\theta(a_t|s_t)}{\\pi_{\\theta_{old}}(a_t|s_t)}$ 为新旧策略的概率比。PPO通过裁剪（Clipping）来限制这个比率在一个预设的范围 $[1-\\epsilon, 1+\\epsilon]$ 内。请拖动 $\\epsilon$ 滑块来调整信任域大小，并切换"好动作"与"坏动作"的情景，观察目标函数如何被裁剪。</p><div class="flex justify-center items-center gap-6 mb-4"><button id="ppo-toggle-advantage" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">切换到 "坏动作"</button><div class="w-64"><label for="epsilon-slider" class="font-medium flex justify-between">裁剪范围 $\\epsilon$: <span id="epsilon-value">0.2</span></label><input type="range" id="epsilon-slider" min="0.05" max="0.5" step="0.01" value="0.2" class="slider w-full h-2 bg-themed-muted rounded-lg appearance-none cursor-pointer"></div></div><canvas id="ppo-canvas" class="w-full h-64 bg-themed-muted border border-themed rounded-lg"></canvas><p id="ppo-explanation" class="text-center mt-2 font-medium"></p></div><div class="card p-6 mt-6"><h3 class="text-xl font-bold">PPO核心组件与伪代码</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="space-y-4"><div class="p-4 bg-blue-500/10 rounded-lg"><h4 class="font-bold text-blue-600 dark:text-blue-400">裁剪代理目标</h4><p class="text-sm mt-2">这是PPO的核心创新，它通过取未裁剪和已裁剪目标的较小值，悲观地限制了策略更新的幅度，避免策略突变。</p><div class="p-2 my-2 bg-themed-secondary rounded text-center">$$L^{CLIP}(\\theta) = \\mathbb{E}_t \\left[ \\min\\left(r_t(\\theta)\\hat{A}_t, \\text{clip}(r_t(\\theta), 1-\\epsilon, 1+\\epsilon)\\hat{A}_t\\right) \\right]$$</div></div><div class="p-4 bg-green-500/10 rounded-lg"><h4 class="font-bold text-green-600 dark:text-green-400">广义优势估计 (GAE)</h4><p class="text-sm mt-2">PPO通常采用GAE来准确估计优势函数。GAE通过加权平均多个时间步的TD误差，有效降低了优势估计的方差，提供了更稳定的优势信号。</p></div></div><div><h4 class="font-bold">PPO 伪代码</h4><pre><code>Initialize policy and value networks
for iteration = 1, 2, ... do
  // 1. Data Collection
  Run old policy to collect trajectories
  // 2. Advantage & Return Calculation
  Compute advantages (GAE) and returns
  // 3. Optimization
  for K epochs do
    for mini_batch in trajectories do
      Update policy via clipped objective
      Update value function via MSE
    end for
  end for
  Update old policy
end for</code></pre></div></div></div>`,
            'chapter6': `<h2>第6章: SAC算法详解</h2><p class="text-lg text-themed-secondary mb-6">软演员-评论家（SAC）是一种基于最大熵强化学习框架的off-policy算法。SAC的目标是最大化奖励的同时，也最大化策略的**熵**（随机性），带来了极强的鲁棒性和探索效率，在许多连续控制任务中表现优异。</p><div class="card p-6"><h3 class="text-xl font-bold">交互式理解：探索与利用的权衡</h3><p class="text-themed-secondary mb-4">SAC的目标函数是 $J(\\pi) = \\sum \\mathbb{E} [r(s_t, a_t) + \\alpha \\mathcal{H}(\\pi(\\cdot|s_t))]$。其中 $\\mathcal{H}$ 是策略的熵，$\\alpha$ 是控制熵重要性的温度参数。请调整温度参数 $\\alpha$，观察策略（蓝色区域）的变化。高 $\\alpha$ 鼓励探索，低 $\\alpha$ 鼓励利用。</p><canvas id="sac-canvas" class="w-full h-64 bg-themed-muted border border-themed rounded-lg"></canvas><div class="mt-4"><label for="alpha-slider" class="font-medium flex justify-between">温度 $\\alpha$: <span id="alpha-value">0.20</span></label><input type="range" id="alpha-slider" min="0.01" max="1.0" step="0.01" value="0.2" class="slider w-full h-2 bg-themed-muted rounded-lg appearance-none cursor-pointer"></div><p id="sac-explanation" class="text-center mt-2 font-medium"></p></div><div class="card p-6 mt-6"><h3 class="text-xl font-bold">SAC核心组件</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="p-4 bg-purple-500/10 rounded-lg"><h4 class="font-bold text-purple-600 dark:text-purple-400">双Q网络 (Twin Q-Critics)</h4><p class="text-sm mt-2">为了缓解价值函数在off-policy学习中被过高估计的问题（Q-value overestimation），SAC采用两个独立的Q网络，并在计算TD目标时悲观地取其较小值，使学习过程更稳定。</p></div><div class="p-4 bg-teal-500/10 rounded-lg"><h4 class="font-bold text-teal-600 dark:text-teal-400">自动熵调优</h4><p class="text-sm mt-2">手动选择一个固定的 $\\alpha$ 很困难。SAC能将 $\\alpha$ 作为一个可训练参数，自动调整它以使策略的实际熵动态地接近一个预设的目标熵，实现了探索和利用的自动平衡。</p></div></div></div>`,
            'quiz1': `<h2>阶段小测: 核心算法</h2><p class="text-lg text-themed-secondary mb-6">检验一下您对核心算法章节的理解程度吧！</p><div id="quiz-container" class="card p-6"></div>`,
            'chapter7': `<h2>第7章: CMDP构建实验室</h2><p class="text-lg text-themed-secondary mb-6">对于既要追求经济效益，又必须遵守安全红线的任务（如锅炉壁温不能超限），我们引入**约束马尔可夫决策过程（CMDP）**。智能体的目标是在满足成本约束的前提下，最大化累积奖励。</p><div class="card p-6"><div class="grid grid-cols-1 lg:grid-cols-2 gap-8"><div id="cmdp-builder-panel"><h3 class="text-xl font-bold">1. 构建您的CMDP模型</h3><p class="text-themed-secondary mb-6">请勾选您希望纳入模型的变量。<b>奖励</b>是我们希望最大化的指标，而<b>成本/约束</b>是我们必须遵守的红线。</p><div class="mb-4"><h4 class="font-bold text-lg mb-2 text-indigo-500 dark:text-indigo-400">S - 选择状态</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-nox-meter" checked> NOx浓度</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-co-meter" checked> CO浓度</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-efficiency-meter" checked> 热效率</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-temp-meter" checked> 关键壁温</label></div></div><div class="mb-4"><h4 class="font-bold text-lg mb-2 text-green-600 dark:text-green-500">A - 选择动作</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-air-slider" checked> 总风量</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-tilt-slider" checked> 燃烧器摆角</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-ofa-slider" checked> 燃尽风占比</label></div></div><div class="mb-4"><h4 class="font-bold text-lg mb-2 text-amber-600 dark:text-amber-500">R - 定义奖励</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-efficiency-meter" data-type="reward" checked> 奖励：提升热效率</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-nox-meter" data-type="reward"> 奖励：降低NOx</label></div></div><div class="mb-4"><h4 class="font-bold text-lg mb-2 text-red-600 dark:text-red-500">C - 定义成本/约束</h4><div class="space-y-2 text-sm p-4 bg-themed-muted rounded-lg"><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-temp-meter" data-type="cost" checked> 约束：壁温</label><label class="flex items-center"><input type="checkbox" class="mr-2 cmdp-checkbox" data-target="component-co-meter" data-type="cost"> 约束：CO浓度</label></div></div></div><div><h3 class="text-xl font-bold">2. 实时预览与交互</h3><p class="text-themed-secondary mb-6">这里是您构建的虚拟锅炉。被定义为"奖励"的模块会以绿色高亮，"约束"模块以红色高亮。</p><div class="p-4 rounded-lg bg-slate-700 flex flex-col items-center justify-start min-h-[500px]"><h4 class="font-bold text-lg mb-2 text-white">🔥 虚拟锅炉实时视图</h4><div id="boiler-visual-container-ch7" class="w-48 h-64 bg-slate-800 rounded-t-lg relative overflow-hidden mt-4"><div id="flame-visual-ch7" class="flame-visual"></div></div><div id="dashboard-ch7" class="w-full mt-6 space-y-4 p-2"><div id="component-nox-meter" class="preview-component p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">NOx</label><div class="w-full bg-slate-500 rounded-full h-3"><div id="nox-meter-fill-ch7" class="bg-red-500 h-3 rounded-full"></div></div></div><div id="component-co-meter" class="preview-component p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">CO</label><div class="w-full bg-slate-500 rounded-full h-3"><div id="co-meter-fill-ch7" class="bg-amber-500 h-3 rounded-full"></div></div></div><div id="component-temp-meter" class="preview-component p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">壁温</label><div class="w-full bg-slate-500 rounded-full h-3"><div id="temp-meter-fill-ch7" class="bg-orange-500 h-3 rounded-full"></div></div></div><div id="component-efficiency-meter" class="preview-component p-2 rounded-md transition-all duration-300"><label class="font-medium text-white text-sm">热效率</label><div class="text-right"><span id="efficiency-value-ch7" class="text-xl font-bold text-green-400">92.50</span> %</div></div></div></div><div id="controls-ch7" class="mt-4 p-4 bg-themed-secondary rounded-lg space-y-4 border border-themed"><div id="component-air-slider" class="preview-component"><label for="air-slider-ch7" class="font-medium flex justify-between text-sm">总风量: <span id="air-value-ch7">75</span>%</label><input type="range" id="air-slider-ch7" min="50" max="100" value="75" class="slider w-full"></div><div id="component-tilt-slider" class="preview-component"><label for="tilt-slider-ch7" class="font-medium flex justify-between text-sm">摆角: <span id="tilt-value-ch7">0</span>°</label><input type="range" id="tilt-slider-ch7" min="-15" max="15" value="0" class="slider w-full"></div><div id="component-ofa-slider" class="preview-component"><label for="ofa-slider-ch7" class="font-medium flex justify-between text-sm">OFA占比: <span id="ofa-value-ch7">30</span>%</label><input type="range" id="ofa-slider-ch7" min="10" max="50" value="30" class="slider w-full"></div></div></div></div><div class="mt-8 pt-4 border-t border-themed"><h3 class="text-xl font-bold">3. 您生成的CMDP模型</h3><div id="cmdp-summary-ch7" class="text-sm grid grid-cols-2 md:grid-cols-4 gap-4 p-4 bg-indigo-500/10 rounded-lg mt-4"><div><strong>状态:</strong><ul id="summary-State-ch7" class="list-disc list-inside"></ul></div><div><strong>动作:</strong><ul id="summary-Action-ch7" class="list-disc list-inside"></ul></div><div><strong>奖励:</strong><ul id="summary-Reward-ch7" class="list-disc list-inside"></ul></div><div><strong>成本:</strong><ul id="summary-Cost-ch7" class="list-disc list-inside"></ul></div></div></div></div>`,
            'chapter8': `<h2>第8章: 构建数字孪生</h2><p class="text-lg text-themed-secondary mb-6">RL需要在环境中进行海量试错，这在真实的工业设备上是不可行的。因此，构建一个高保真的仿真环境——"数字孪生"——是项目成功的先决条件。</p><div class="card p-6 mb-6"><h3 class="text-xl font-bold">什么是数字孪生？</h3><p class="text-themed-secondary">数字孪生是真实物理系统的虚拟副本，能模拟真实锅炉的动态响应。构建方法主要有两类：</p><ul class="list-disc list-inside space-y-2 text-themed-secondary"><li><b>机理建模</b>：基于物理定律（如流体力学、传热学、化学反应动力学）构建复杂的微分方程组。优点是泛化性强，可解释性好；缺点是建模难度大，计算量巨大。</li><li><b>数据驱动建模</b>：利用电厂DCS系统积累的历史数据，通过机器学习方法（如LSTM、Transformer）学习输入（控制动作）与输出（状态指标）的映射关系。优点是建模快速；缺点是依赖数据质量，泛化能力和可解释性可能较差。</li></ul><p class="text-themed-secondary mt-4">在实践中，通常将两者结合，用机理模型搭建基础框架，再用数据驱动模型修正和拟合机理模型与现实的偏差。</p></div><div class="card p-6 mb-6"><h3 class="text-xl font-bold">"仿真到现实"的鸿沟 (Sim-to-Real Gap)</h3><p class="mb-4 text-themed-secondary">任何仿真都无法100%复刻现实。缩小这个鸿沟至关重要。一种有效的技术是**领域随机化 (Domain Randomization)**：在训练时，故意给仿真环境增加各种随机性（如传感器噪声、执行器延迟、煤质波动等），迫使AI学习一个对这些不确定性不敏感的、更为鲁棒的策略。</p></div><div class="card p-6"><h3 class="text-xl font-bold">交互演示：模型质量与鲁棒性</h3><p class="text-themed-secondary mb-4">拖动滑块模拟模型与现实的匹配程度。黑色实线代表"真实世界"，蓝色虚线代表数字孪生模型的预测。匹配度越低，"Sim-to-Real"的鸿沟越大。</p><canvas id="sim-real-canvas" class="w-full h-64 bg-themed-muted border border-themed rounded-lg"></canvas><div><label for="model-quality-slider" class="font-medium flex justify-between">模型-现实匹配度: <span id="model-quality-value">50</span>%</label><input type="range" id="model-quality-slider" min="10" max="98" step="1" value="50" class="slider w-full h-2 bg-themed-muted rounded-lg"></div></div>`,
            'chapter9': `<h2>第9章: 训练实验与调试</h2><p class="text-lg text-themed-secondary mb-8">欢迎来到RL训练实验室！智能体（蓝色圆点）的目标是在简化的状态网格中，从'S'出发，尽快到达'🏆'，同时避开危险区域'☠️'。您可以通过调节超参数，观察AI学习行为和最终策略的变化。这是一个经典的Q-Learning示例。</p><div class="grid grid-cols-1 lg:grid-cols-3 gap-6"><div class="lg:col-span-1 card p-6"><h3 class="text-xl font-bold">参数调节</h3><div class="space-y-4"><div><label for="gamma-slider" class="font-medium flex justify-between">远见程度 ($\\gamma$): <span id="gamma-value">0.9</span></label><input type="range" id="gamma-slider" min="0.5" max="0.99" step="0.01" value="0.9" class="slider w-full"></div><div><label for="lr-slider" class="font-medium flex justify-between">学习率 ($\\alpha_{lr}$): <span id="lr-value">0.1</span></label><input type="range" id="lr-slider" min="0.01" max="0.5" step="0.01" value="0.1" class="slider w-full"></div><div><label for="epsilon-slider-ch9" class="font-medium flex justify-between">探索率 ($\\epsilon$): <span id="epsilon-value-ch9">0.2</span></label><input type="range" id="epsilon-slider-ch9" min="0.05" max="1.0" step="0.05" value="0.2" class="slider w-full"></div></div><button id="start-sim" class="mt-6 w-full bg-indigo-600 text-white font-bold py-3 rounded-lg hover:bg-indigo-700 transition-colors">开始 / 重置训练</button></div><div class="lg:col-span-2 card p-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><h3 class="text-xl font-bold">状态空间 (策略可视化)</h3><canvas id="rl-canvas" class="w-full bg-themed-muted border border-themed rounded-lg aspect-square"></canvas><div class="flex justify-around text-xs mt-2 flex-wrap"><span class="flex items-center"><div class="w-3 h-3 rounded-full bg-blue-500 mr-1"></div>智能体</span><span class="flex items-center"><div class="w-3 h-3 rounded-full bg-green-200 mr-1"></div>目标</span><span class="flex items-center"><div class="w-3 h-3 rounded-full bg-red-200 mr-1"></div>危险</span></div></div><div><h3 class="text-xl font-bold">学习曲线 (平均奖励)</h3><div class="w-full h-64 border border-themed rounded-lg p-2"><canvas id="rewardChart"></canvas></div><div class="mt-2 text-center text-sm"><p>回合: <span id="episode-counter">0</span></p><p>平均奖励: <span id="total-reward">0</span></p></div></div></div></div></div>`,
            'chapter10': `<h2>第10章: 三阶段安全部署</h2><p class="text-lg text-themed-secondary mb-6">将AI安全地引入到现实工厂中，是一个比算法本身更具挑战性的工程问题。我们必须采用一套循序渐进的策略，其核心是建立信任、管理风险，确保万无一失。</p><div class="flex flex-col lg:flex-row gap-6"><div class="w-full lg:w-1/3 space-y-2"><div id="step1" class="p-4 rounded-lg cursor-pointer deployment-step" onclick="selectStep(1)"><h4 class="font-bold text-lg">阶段一：建议模式</h4><p class="text-sm">AI作为"影子顾问"，零风险验证性能。</p></div><div id="step2" class="p-4 rounded-lg cursor-pointer deployment-step" onclick="selectStep(2)"><h4 class="font-bold text-lg">阶段二：监督控制</h4><p class="text-sm">AI调整PID设定值，利用现有系统作为安全网。</p></div><div id="step3" class="p-4 rounded-lg cursor-pointer deployment-step" onclick="selectStep(3)"><h4 class="font-bold text-lg">阶段三：直接控制</h4><p class="text-sm">AI直接输出指令，但须通过"安全层"过滤。</p></div></div><div id="step-content" class="flex-1 card p-6 min-h-[300px]"></div></div>`,
            'chapter11': `<h2>第11章: 总结与未来</h2><p class="text-lg text-themed-secondary mb-6">我们从锅炉原理出发，探讨了如何将工业问题抽象为CMDP模型，介绍了PPO和SAC等算法，并阐述了从数字孪生到三阶段安全部署的完整工程实践框架。成功的工业AI应用，是**算法、领域知识和工程实践**三者深度融合的产物。</p><div class="card p-6"><h3 class="text-xl font-bold">未来研究方向</h3><p class="text-themed-secondary mb-6">锅炉优化领域仍有广阔的探索空间：</p><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><div class="p-4 bg-themed-muted rounded-lg hover:shadow-md transition"><h4 class="font-bold text-lg">多智能体 (MARL)</h4><p class="text-sm mt-2">将每个燃烧器视为一个独立的智能体，学习协同配合，以实现比单智能体更精细的控制。</p></div><div class="p-4 bg-themed-muted rounded-lg hover:shadow-md transition"><h4 class="font-bold text-lg">可解释性 (XAI)</h4><p class="text-sm mt-2">让AI不再是"黑箱"，能够解释其决策原因，对于建立操作员信任至关重要。</p></div><div class="p-4 bg-themed-muted rounded-lg hover:shadow-md transition"><h4 class="font-bold text-lg">迁移学习与终身学习</h4><p class="text-sm mt-2">将在A机组上训练好的模型，快速适配到B机组上。并让模型在上线后能持续地在线学习，适应新情况。</p></div></div></div>`,
            'chapter12': `<h2>第12章: 高级主题 - 离线强化学习</h2><p class="text-lg text-themed-secondary mb-6">在许多现实世界的工业应用中，让一个未经训练的智能体自由地与环境（如真实的锅炉）交互来进行"试错"学习是不可行的——成本高昂且风险巨大。离线强化学习（Offline Reinforcement Learning）正是在这种背景下应运而生的一套关键技术。</p><div class="card p-6 mb-6"><h3 class="text-xl font-bold">什么是离线RL？</h3><p class="text-themed-secondary mb-4">与传统的在线RL（Online RL）在学习过程中可以不断与环境交互并收集新数据不同，离线RL的目标是**仅从一个预先收集好的、固定的历史数据集中学习出一个有效的策略**。这个数据集可能来自于人类专家的操作记录、传统控制器（如PID）的运行日志，或者之前其他策略的运行数据。</p><div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center"><div class="p-4 bg-blue-500/10 rounded-lg"><h4 class="font-bold text-blue-600 dark:text-blue-400">在线RL (Online RL)</h4><p class="text-sm mt-2">智能体与环境构成一个闭环。智能体执行动作 -> 环境反馈 -> 智能体更新策略 -> 执行新动作... 这个循环不断进行。</p></div><div class="p-4 bg-green-500/10 rounded-lg"><h4 class="font-bold text-green-600 dark:text-green-400">离线RL (Offline RL)</h4><p class="text-sm mt-2">学习过程与数据收集过程完全分离。我们只有一个固定的数据集 $D = \\{(s, a, r, s')\\}$，并且在学习期间无法与环境进行任何新的交互。</p></div></div></div><div class="card p-6"><h3 class="text-xl font-bold">核心挑战：分布外推误差</h3><p class="text-themed-secondary mb-4">离线RL的主要挑战来自于**分布偏移（Distributional Shift）**。当学习的策略 $\\pi_\\theta$ 想要尝试一个动作 $a$，而这个动作在数据集的行为策略 $\\pi_\\beta$ 中很少或从未出现过时，价值函数对这个"分布外"（Out-of-Distribution, OOD）动作的估计就会变得非常不准确，产生巨大的外推误差。现代离线RL算法的核心思想是**策略约束（Policy Constraint）**，即学习的策略应该被约束，使其尽可能地与数据集中的行为策略保持接近。</p><div id="offline-rl-diagram" class="p-4 bg-themed-muted rounded-lg flex justify-center items-center mt-4"></div></div>`,
            'glossary': `<h2>关键术语表 (Glossary)</h2><p class="text-lg text-themed-secondary mb-6">这里汇总了本平台中出现的关键强化学习术语，方便您随时查阅。</p>
                        <div class="space-y-4">
                            <div class="card p-4"><h3 class="text-lg font-bold mt-0">Model-Based vs. Model-Free (基于模型 vs. 无模型)</h3><p class="text-sm text-themed-secondary">基于模型的RL尝试学习环境的模型（即状态转移函数P和奖励函数R），然后利用这个模型进行规划。无模型的RL则不学习模型，直接学习一个策略或价值函数。PPO和SAC都是无模型算法。</p></div>
                            <div class="card p-4"><h3 class="text-lg font-bold mt-0">On-Policy vs. Off-Policy (同策略 vs. 异策略)</h3><p class="text-sm text-themed-secondary">同策略算法使用当前策略产生的数据来更新当前策略（如PPO）。异策略算法可以使用过去策略（甚至人类专家）产生的数据来更新当前策略（如DQN, SAC），这通常能带来更高的数据效率。</p></div>
                            <div class="card p-4"><h3 class="text-lg font-bold mt-0">Exploration vs. Exploitation (探索 vs. 利用)</h3><p class="text-sm text-themed-secondary">探索是指尝试新的、未知的动作以发现可能更好的奖励；利用是指执行当前已知的最优动作以最大化短期奖励。在RL中找到二者的平衡至关重要。</p></div>
                            <div class="card p-4"><h3 class="text-lg font-bold mt-0">Credit Assignment Problem (信度分配问题)</h3><p class="text-sm text-themed-secondary">指在一个长序列的动作之后获得了一个奖励（或惩罚），如何判断这个结果是哪个（或哪些）动作的功劳（或过错）。</p></div>
                            <div class="card p-4"><h3 class="text-lg font-bold mt-0">Sim-to-Real Gap (仿真到现实的鸿沟)</h3><p class="text-sm text-themed-secondary">指在仿真环境中训练出的策略，在部署到真实物理世界时性能下降的现象。这是因为仿真环境无法100%精确地模拟真实世界。缩小这一鸿沟是工程实践中的核心挑战。</p></div>
                        </div>`,
            'team': `<h2>团队介绍</h2><p class="text-lg text-themed-secondary mb-6">我们是一支致力于将前沿人工智能技术与工业实践相结合的团队，专注于为能源、制造等关键领域提供高效、可靠的智能化解决方案。</p><div class="flex flex-col items-center"><img src="image/seu-logo.png" alt="东南大学logo" style="width:96px;max-width:30vw;" class="mb-6"><div class="card text-center p-10" style="max-width:420px;"><img class="w-48 h-48 rounded-full mx-auto mb-6 border-4 border-indigo-200" src="image/my-photo.jpg" alt="侯冠辰"><h3 class="text-2xl font-bold m-0 mb-2">侯冠辰</h3><p class="text-indigo-500 dark:text-indigo-400 text-lg mb-2">项目负责人 & 算法工程师</p><p class="text-base text-themed-secondary">负责核心强化学习算法的研发、模型训练与部署策略制定。</p></div></div>`,
            'resources': `<h2>关键资源</h2><p class="text-lg text-themed-secondary mb-6">本平台内容深受以下经典研究与资料的启发。我们强烈推荐希望深入学习的同学阅读和探索。</p><div class="space-y-8"><div><h3 class="text-xl font-bold">奠基性论文</h3><ul class="list-disc list-inside space-y-2 mt-4 text-themed-secondary"><li>Mnih, V., et al. (2015). <a href="https://www.nature.com/articles/nature14236" target="_blank" class="text-indigo-500 hover:underline">Human-level control through deep reinforcement learning</a>. Nature. (DQN)</li><li>Schulman, J., et al. (2017). <a href="https://arxiv.org/abs/1707.06347" target="_blank" class="text-indigo-500 hover:underline">Proximal Policy Optimization Algorithms</a>. arXiv. (PPO)</li><li>Haarnoja, T., et al. (2018). <a href="https://arxiv.org/abs/1812.05905" target="_blank" class="text-indigo-500 hover:underline">Soft Actor-Critic Algorithms and Applications</a>. arXiv. (SAC)</li><li>Levine, S., et al. (2020). <a href="https://arxiv.org/abs/2004.07219" target="_blank" class="text-indigo-500 hover:underline">Offline Reinforcement Learning: Tutorial, Review, and Perspectives on Open Problems</a>. arXiv. (Offline RL)</li></ul></div><div><h3 class="text-xl font-bold">推荐书籍</h3><ul class="list-disc list-inside space-y-2 mt-4 text-themed-secondary"><li>Sutton, R. S., & Barto, A. G. (2018). <a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" class="text-indigo-500 hover:underline">Reinforcement Learning: An Introduction</a>. MIT press. (被誉为RL领域的"圣经")</li><li>Goodfellow, I., Bengio, Y., & Courville, A. (2016). <a href="https://www.deeplearningbook.org/" target="_blank" class="text-indigo-500 hover:underline">Deep Learning</a>. MIT press. (深度学习领域的权威著作)</li></ul></div><div><h3 class="text-xl font-bold">在线课程与资源</h3><ul class="list-disc list-inside space-y-2 mt-4 text-themed-secondary"><li><a href="https://spinningup.openai.com/en/latest/" target="_blank" class="text-indigo-500 hover:underline">OpenAI Spinning Up in Deep RL</a>: OpenAI出品的优秀深度强化学习入门教程。</li><li><a href="https://huggingface.co/deep-rl-course/unit0/introduction" target="_blank" class="text-indigo-500 hover:underline">Hugging Face Deep RL Course</a>: Hugging Face推出的免费深度强化学习课程。</li></ul></div></div>`
        };

        function initChapter1() {
            initBoilerSandbox();
            renderBoilerDiagram();
            renderRankineDiagram();
        }
        function initChapter2() {
            initBellmanGrid();
            renderRlTaxonomy();
        }
        function initBoilerSandbox() {
            const sliders = {
                load: document.getElementById('load-slider'),
                air: document.getElementById('air-total-slider'),
                tilt: document.getElementById('burner-tilt-slider'),
                ofa: document.getElementById('o2-dist-slider')
            };
            if (!sliders.load) return;

            const values = {
                load: document.getElementById('load-value'),
                air: document.getElementById('air-total-value'),
                tilt: document.getElementById('burner-tilt-value'),
                ofa: document.getElementById('o2-dist-value')
            };
            const visuals = {
                flame: document.getElementById('flame-visual'),
                nox: document.getElementById('nox-meter-fill'),
                co: document.getElementById('co-meter-fill'),
                efficiency: document.getElementById('efficiency-value')
            };
            
            const paretoCtx = document.getElementById('pareto-chart')?.getContext('2d');
            let paretoChart;
            let workingPointHistory = [];

            function updateBoilerSimulation() {
                const load = parseFloat(sliders.load.value);
                const air = parseFloat(sliders.air.value);
                const tilt = parseFloat(sliders.tilt.value);
                const ofa = parseFloat(sliders.ofa.value);
                
                values.load.textContent = load.toFixed(0);
                values.air.textContent = air.toFixed(0);
                values.tilt.textContent = tilt.toFixed(0);
                values.ofa.textContent = ofa.toFixed(0);

                const load_factor = load / 100;
                let nox_raw = (air * 1.2 - ofa * 1.5 + Math.abs(tilt) * 0.8) * (0.8 + load_factor * 0.4);
                let co_raw = (150 - air + (Math.abs(air - 85) * 0.5)) * (0.9 + load_factor * 0.2);
                let eff_base = 90.5 + load_factor * 2;
                let eff_air = 1 - Math.abs(air - (80 + load_factor * 5)) / 50;
                let eff_ofa = 1 - Math.abs(ofa - 35) / 40;
                let efficiency_raw = eff_base + (eff_air * 1.5) + (eff_ofa * 1) - (co_raw / 150);

                const nox = Math.max(10, Math.min(100, nox_raw));
                const co = Math.max(5, Math.min(100, co_raw));
                const efficiency = Math.max(88, Math.min(94.5, efficiency_raw));
                
                // --- 增强火焰动画 ---
                const flameHeight = (30 + (air / 100) * 80) * (0.7 + load_factor * 0.4);
                const flameSkew = tilt * -0.8;
                visuals.flame.style.height = `${flameHeight}%`;
                visuals.flame.style.transform = `translateY(${tilt * -2}px) skewX(${flameSkew}deg)`;
                // --- 结束增强 ---
                
                visuals.nox.style.width = `${nox}%`;
                visuals.co.style.width = `${co}%`;
                visuals.efficiency.textContent = efficiency.toFixed(2);

                updateParetoChart(efficiency, nox);
            }

            function generateParetoFront() {
                const front = [];
                for (let eff = 94.5; eff >= 90; eff -= 0.1) {
                    let nox = 30 + Math.pow(94.5 - eff, 2) * 2;
                    nox += (Math.random() - 0.5) * 5;
                    front.push({x: nox, y: eff});
                }
                return front.sort((a,b) => a.x - b.x);
            }

            function updateParetoChart(efficiency, nox) {
                if (!paretoCtx) return;
                
                const newPoint = {x: nox, y: efficiency};
                workingPointHistory.push(newPoint);
                if (workingPointHistory.length > 20) workingPointHistory.shift();

                if (paretoChart) paretoChart.destroy();
                
                const isDark = document.documentElement.classList.contains('dark');
                const gridColor = isDark ? 'rgba(148, 163, 184, 0.2)' : 'rgba(0, 0, 0, 0.1)';
                const textColor = isDark ? '#94a3b8' : '#475569';

                paretoChart = new Chart(paretoCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: '帕累托最优前沿', data: generateParetoFront(), borderColor: 'rgba(220, 38, 38, 0.5)', borderWidth: 2, borderDash: [5, 5], pointRadius: 0, showLine: true, fill: false,
                        },{
                            label: '历史轨迹', data: workingPointHistory, backgroundColor: 'rgba(100, 116, 139, 0.3)', pointRadius: 3,
                        },{
                            label: '当前工作点', data: [newPoint], backgroundColor: 'rgb(79, 70, 229)', pointRadius: 8, pointHoverRadius: 10,
                        }]
                    },
                    options: {
                        animation: false,
                        scales: { 
                            x: { title: { display: true, text: 'NOx 排放', color: textColor }, min: 20, max: 100, grid: { color: gridColor }, ticks: { color: textColor } }, 
                            y: { title: { display: true, text: '热效率 (%)', color: textColor }, min: 88, max: 95, grid: { color: gridColor }, ticks: { color: textColor } } 
                        },
                        plugins: { legend: { position: 'bottom', labels: { color: textColor } } }
                    }
                });
            }

            Object.values(sliders).forEach(slider => slider.addEventListener('input', updateBoilerSimulation));
            updateBoilerSimulation();
        }
        
        function initBellmanGrid() {
            const canvas = document.getElementById('bellman-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const iterateBtn = document.getElementById('iterate-bellman-btn');
            const solveBtn = document.getElementById('solve-bellman-btn');
            const resetBtn = document.getElementById('reset-bellman-btn');
            const iterCountEl = document.getElementById('bellman-iteration-count');
            const updateInfoEl = document.getElementById('bellman-update-info');
            const methodSelect = document.getElementById('dp-method-select');
            const phaseInfoEl = document.getElementById('pi-phase-info');

            const GRID_SIZE = 5;
            const GAMMA = 0.9;
            const REWARDS = { goal: 1, trap: -1, step: 0 };
            const goal = {x: 4, y: 4};
            const traps = [{x: 2, y: 2}, {x: 1, y: 3}];
            const walls = [{x: 3, y: 1}];

            let values, policy, iterationCount, pi_phase, convergence_threshold = 1e-4;
            let currentValues, targetValues;

            function reset() {
                if (window.bellmanInterval) clearInterval(window.bellmanInterval);
                if (state.activeAnimationFrames.bellman) cancelAnimationFrame(state.activeAnimationFrames.bellman);
                
                solveBtn.disabled = false;
                iterateBtn.disabled = false;
                solveBtn.innerHTML = '<i class="fa-solid fa-robot"></i> 自动求解';
                iterationCount = 0;
                values = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                policy = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(Math.floor(Math.random() * 4)));
                
                currentValues = JSON.parse(JSON.stringify(values));
                targetValues = JSON.parse(JSON.stringify(values));

                iterCountEl.textContent = iterationCount;
                updateInfoEl.textContent = '环境已重置。请开始迭代...';
                pi_phase = 'evaluation';
                updatePhaseDisplay();
                
                animateGrid();
            }

            function iterate() {
                const method = methodSelect.value;
                let is_converged = false;
                if (method === 'vi') { is_converged = valueIterationStep(); } 
                else { is_converged = policyIterationStep(); }
                iterationCount++;
                iterCountEl.textContent = iterationCount;
                targetValues = JSON.parse(JSON.stringify(values));
                return is_converged;
            }
            
            function autoSolve() {
                solveBtn.disabled = true;
                iterateBtn.disabled = true;
                solveBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> 求解中...';
                if (window.bellmanInterval) clearInterval(window.bellmanInterval);
                window.bellmanInterval = setInterval(() => {
                    const converged = iterate();
                    if (converged) {
                        clearInterval(window.bellmanInterval);
                        solveBtn.innerHTML = '<i class="fa-solid fa-check"></i> 求解完成';
                        const method = methodSelect.value === 'vi' ? '价值迭代' : '策略迭代';
                        updateInfoEl.textContent = `${method}已收敛！`;
                    }
                }, 100);
            }

            function valueIterationStep() {
                let newValues = JSON.parse(JSON.stringify(values));
                let maxChange = 0;
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (isWall(x, y) || isTerminal(x, y)) continue;
                        const actionValues = getActionValues(x, y, values);
                        const bestValue = Math.max(...actionValues);
                        newValues[y][x] = REWARDS.step + GAMMA * bestValue;
                        maxChange = Math.max(maxChange, Math.abs(newValues[y][x] - values[y][x]));
                    }
                }
                values = newValues;
                updatePolicyBasedOnValues();
                updateInfoEl.textContent = `价值迭代 | 最大变化: ${maxChange.toFixed(5)}`;
                return maxChange < convergence_threshold;
            }

            function policyIterationStep() {
                let policy_stable = true;
                if (pi_phase === 'evaluation') {
                    let maxChange = 0;
                    for (let sweep = 0; sweep < 5; sweep++) { 
                        let currentMaxChange = 0;
                        for (let y = 0; y < GRID_SIZE; y++) {
                            for (let x = 0; x < GRID_SIZE; x++) {
                                if (isWall(x, y) || isTerminal(x, y)) continue;
                                const currentAction = policy[y][x];
                                const actionValue = getActionValues(x, y, values)[currentAction];
                                const newValue = REWARDS.step + GAMMA * actionValue;
                                currentMaxChange = Math.max(currentMaxChange, Math.abs(newValue - values[y][x]));
                                values[y][x] = newValue;
                            }
                        }
                        maxChange = currentMaxChange;
                    }
                    updateInfoEl.textContent = `策略评估 | 最大变化: ${maxChange.toFixed(5)}`;
                    if (maxChange < convergence_threshold) pi_phase = 'improvement';
                } else { // improvement phase
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            if (isTerminal(x, y) || isWall(x, y)) continue;
                            let old_action = policy[y][x];
                            const actionValues = getActionValues(x, y, values);
                            policy[y][x] = actionValues.indexOf(Math.max(...actionValues));
                            if (old_action !== policy[y][x]) policy_stable = false;
                        }
                    }
                    updateInfoEl.textContent = `策略提升 | 策略稳定: ${policy_stable}`;
                    pi_phase = 'evaluation';
                    if (policy_stable) return true;
                }
                updatePhaseDisplay();
                return false;
            }
            
            function getActionValues(x, y, value_grid) {
                const actions = [[0, -1], [0, 1], [-1, 0], [1, 0]]; // U, D, L, R
                return actions.map(([dx, dy]) => {
                    const nx = x + dx, ny = y + dy;
                    if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE || isWall(nx, ny)) {
                        return value_grid[y][x];
                    }
                    return value_grid[ny][nx];
                });
            }
            
            function updatePolicyBasedOnValues() {
                 for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (isTerminal(x, y) || isWall(x, y)) continue;
                        const actionValues = getActionValues(x, y, values);
                        policy[y][x] = actionValues.indexOf(Math.max(...actionValues));
                    }
                }
            }

            function isTerminal(x, y) { return (x === goal.x && y === goal.y) || traps.some(t => t.x === x && t.y === y); }
            function isWall(x, y) { return walls.some(w => w.x === x && w.y === y); }
            function updatePhaseDisplay() { phaseInfoEl.textContent = methodSelect.value === 'pi' ? (pi_phase === 'evaluation' ? '评估中' : '提升中') : 'N/A'; }

            function animateGrid() {
                const cellSize = canvas.width / GRID_SIZE;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const isDark = document.documentElement.classList.contains('dark');
                let needsAnotherFrame = false;

                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const diff = targetValues[y][x] - currentValues[y][x];
                        if (Math.abs(diff) > 0.001) {
                            currentValues[y][x] += diff * 0.1; // Interpolation
                            needsAnotherFrame = true;
                        } else {
                            currentValues[y][x] = targetValues[y][x];
                        }
                        
                        const val = currentValues[y][x];
                        const heat = (val - REWARDS.trap) / (REWARDS.goal - REWARDS.trap);
                        const r = Math.floor(255 * (1 - heat));
                        const g = Math.floor(255 * heat);
                        ctx.fillStyle = `rgb(${r}, ${g}, 100)`;
                        if (isWall(x, y)) ctx.fillStyle = '#555';
                        else if (isTerminal(x, y)) ctx.fillStyle = (x === goal.x && y === goal.y) ? 'rgb(100,255,100)' : 'rgb(255,100,100)';
                        
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        ctx.strokeStyle = isDark ? '#475569' : '#ccc';
                        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);

                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        if (isTerminal(x,y) || isWall(x,y)) {
                            ctx.font = `${cellSize*0.6}px sans-serif`;
                            if(x === goal.x && y === goal.y) ctx.fillText('🏆', x*cellSize+cellSize/2, y*cellSize+cellSize/2);
                            else if(isWall(x, y)) ctx.fillText('🧱', x*cellSize+cellSize/2, y*cellSize+cellSize/2);
                            else ctx.fillText('☠️', x*cellSize+cellSize/2, y*cellSize+cellSize/2);
                        } else {
                            ctx.fillStyle = isDark ? '#f1f5f9' : '#1e293b';
                            ctx.font = `bold ${cellSize*0.25}px sans-serif`;
                            ctx.fillText(val.toFixed(2), x*cellSize+cellSize/2, y*cellSize+cellSize/4);
                            if(policy[y][x] !== -1) {
                                 ctx.font = `${cellSize*0.4}px sans-serif`;
                                 const arrows = ['↑', '↓', '←', '→'];
                                 ctx.fillText(arrows[policy[y][x]], x*cellSize+cellSize/2, y*cellSize+cellSize*0.7);
                            }
                        }
                    }
                }
                if (needsAnotherFrame) {
                    state.activeAnimationFrames.bellman = requestAnimationFrame(animateGrid);
                }
            }
            
            iterateBtn.addEventListener('click', () => {
                iterate();
                if (!state.activeAnimationFrames.bellman) animateGrid();
            });
            solveBtn.addEventListener('click', () => {
                autoSolve();
                if (!state.activeAnimationFrames.bellman) animateGrid();
            });
            resetBtn.addEventListener('click', reset);
            methodSelect.addEventListener('change', reset);
            reset();
        }
        
        function initActorCriticViz() {
            const container = document.getElementById('ac-diagram-container');
            if (!container) return;
            const playBtn = document.getElementById('play-ac-viz');
            const explanationEl = document.getElementById('ac-viz-explanation');
            renderAcDiagram(container);
            const svgEl = container.querySelector('svg');
            if (!svgEl) return;
            const allElements = {
                nodes: Array.from(svgEl.querySelectorAll(".ac-node")),
                arrows: Array.from(svgEl.querySelectorAll(".ac-arrow")),
                updateLabel: svgEl.querySelector("#label-update")
            };
            function resetHighlights() {
                allElements.nodes.forEach(el => el.classList.remove('highlight'));
                allElements.arrows.forEach(el => {
                    el.style.stroke = '#9ca3af';
                    el.setAttribute('marker-end', 'url(#arrowhead)');
                });
                if (allElements.updateLabel) allElements.updateLabel.style.fill = 'transparent';
                explanationEl.textContent = "";
            }
            playBtn.addEventListener('click', () => {
                if (playBtn.disabled) return;
                playBtn.disabled = true;
                if(window.acAnimationTimeoutId) clearTimeout(window.acAnimationTimeoutId);
                let stepIndex = 0;
                const steps = [
                    { el: ["node-state"], text: "1. 智能体观察到当前状态 S" },
                    { el: ["arrow-to-actor"], text: "2. 状态 S 被输入给演员 (Actor)" },
                    { el: ["node-actor"], text: "3. 演员根据其策略 $\\pi(a|S)$，选择一个动作 A" },
                    { el: ["arrow-to-action"], text: "4. 演员输出动作 A" },
                    { el: ["node-action"], text: "5. 动作 A 施加于环境" },
                    { el: ["arrow-to-env"], text: "6. 环境接收动作并发生状态转移" },
                    { el: ["node-env"], text: "7. 环境返回新状态S'和奖励R" },
                    { el: ["arrow-to-critic"], text: "8. (S, A, R, S') 被送往评论家进行评估" },
                    { el: ["node-critic"], text: "9. 评论家计算优势函数 A(s,a)" },
                    { el: ["arrow-critic-to-actor", "label-update"], text: "10. 优势函数 A(s,a) 指导演员更新" }
                ];
                function nextStep() {
                    resetHighlights();
                    if (stepIndex >= steps.length) {
                        playBtn.disabled = false;
                        explanationEl.textContent = "流程结束。";
                        if(window.MathJax) MathJax.typesetPromise();
                        return;
                    }
                    const currentStep = steps[stepIndex];
                    explanationEl.innerHTML = currentStep.text;
                    if(window.MathJax) MathJax.typesetPromise();
                    currentStep.el.forEach(id => {
                        const element = svgEl.querySelector(`#${id}`);
                        if (element) {
                            if (element.tagName.toLowerCase() === 'path') {
                                element.style.stroke = '#f97316';
                                element.setAttribute('marker-end', 'url(#arrowhead-h)');
                            } else if (id.includes('node')) {
                                element.classList.add('highlight');
                            } else if (id === 'label-update') {
                                element.style.fill = '#c2410c';
                            }
                        }
                    });
                    stepIndex++;
                    window.acAnimationTimeoutId = setTimeout(nextStep, 1800);
                }
                resetHighlights();
                nextStep();
            });
        }
        function initPpoCanvas() {
            const canvas = document.getElementById('ppo-canvas'); 
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const toggleBtn = document.getElementById('ppo-toggle-advantage');
            const explanationEl = document.getElementById('ppo-explanation');
            const epsilonSlider = document.getElementById('epsilon-slider');
            const epsilonValueEl = document.getElementById('epsilon-value');
            let advantage = 1;
            let epsilon = 0.2;
            function drawPpo(){
                const w = canvas.width, h = canvas.height;
                const isDark = document.documentElement.classList.contains('dark');
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = isDark ? '#475569' : '#cbd5e1';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
                const r1_x = w * (1 - 0.5) / 1.5;
                ctx.moveTo(r1_x, 0); ctx.lineTo(r1_x, h);
                ctx.stroke();
                ctx.fillStyle = isDark ? '#94a3b8' : '#64748b';
                ctx.font = "12px 'Noto Sans SC'";
                ctx.fillText('r(θ)=1', r1_x - 10, h/2 + 15);
                ctx.fillText('目标 L', w/2 - 20, 15);
                ctx.fillText('概率比 r(θ)', w - 60, h/2 + 15);
                ctx.fillStyle = 'rgba(79, 70, 229, 0.05)';
                const clip_lower_x = w * (1 - epsilon - 0.5) / 1.5;
                const clip_upper_x = w * (1 + epsilon - 0.5) / 1.5;
                ctx.fillRect(clip_lower_x, 0, clip_upper_x - clip_lower_x, h);
                ctx.strokeStyle = '#fca5a5';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1.5;
                const y_clip_upper = h/2 - 50 * (1 + epsilon) * advantage;
                const y_clip_lower = h/2 - 50 * (1 - epsilon) * advantage;
                ctx.beginPath(); ctx.moveTo(0, y_clip_upper); ctx.lineTo(w, y_clip_upper); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, y_clip_lower); ctx.lineTo(w, y_clip_lower); ctx.stroke();
                ctx.setLineDash([]);
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i <= w; i++) {
                    const ratio = 0.5 + (i / w) * 1.5;
                    const y_unclipped = h/2 - 50 * ratio * advantage;
                    const y_clipped_val = h/2 - 50 * (ratio > 1 ? (1+epsilon) : (1-epsilon)) * advantage;
                    const y_final = (advantage > 0) ? Math.max(y_unclipped, y_clipped_val) : Math.min(y_unclipped, y_clipped_val);
                    i === 0 ? ctx.moveTo(i, y_final) : ctx.lineTo(i, y_final);
                }
                ctx.stroke();
                if (advantage > 0) {
                    explanationEl.innerHTML = '当优势 $\\hat{A}_t > 0$ (好动作)时，目标函数被 <span class="text-green-600 font-semibold">向上推动</span>，但被上限裁剪，防止策略过于激进。';
                } else {
                    explanationEl.innerHTML = '当优势 $\\hat{A}_t < 0$ (坏动作)时，目标函数被 <span class="text-red-600 font-semibold">向下拉动</span>，但被下限裁剪，防止策略更新过猛。';
                }
                if(window.MathJax) MathJax.typesetPromise();
            }
            toggleBtn.addEventListener('click', () => {
                advantage *= -1;
                toggleBtn.innerHTML = advantage > 0 ? '切换到 "坏动作" ($\\hat{A}_t < 0$)' : '切换到 "好动作" ($\\hat{A}_t > 0$)';
                if(window.MathJax) MathJax.typesetPromise();
                drawPpo();
            });
            epsilonSlider.addEventListener('input', (e) => {
                epsilon = parseFloat(e.target.value);
                epsilonValueEl.textContent = epsilon.toFixed(2);
                drawPpo();
            });
            drawPpo();
        }
        function initSacCanvas() {
            const sacCanvas = document.getElementById('sac-canvas'); 
            if (!sacCanvas) return;
            const sacCtx = sacCanvas.getContext('2d');
            const slider = document.getElementById('alpha-slider');
            const valueDisp = document.getElementById('alpha-value');
            const explanationEl = document.getElementById('sac-explanation');
            let alpha = 0.2;
            slider.addEventListener('input', (e) => {
                alpha = parseFloat(e.target.value);
                valueDisp.textContent = alpha.toFixed(2);
            });
            const rewardLandscape = (x_norm) => Math.sin(x_norm * 2 * Math.PI) * 0.5 + Math.cos(x_norm * 3 * Math.PI) * 0.3;
            let animationTime = 0;
            function drawSac() {
                if (!document.getElementById('sac-canvas')) {
                    if (window.activeAnimationFrames.sac) cancelAnimationFrame(window.activeAnimationFrames.sac);
                    return;
                }
                const w = sacCanvas.width, h = sacCanvas.height;
                sacCtx.clearRect(0, 0, w, h);
                sacCtx.beginPath();
                sacCtx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                sacCtx.lineWidth = 2;
                sacCtx.setLineDash([2, 3]);
                for (let x = 0; x <= w; x++) {
                    const y = h/2 - rewardLandscape(x / w) * h/3;
                    x === 0 ? sacCtx.moveTo(x, y) : sacCtx.lineTo(x, y);
                }
                sacCtx.stroke();
                sacCtx.setLineDash([]);
                sacCtx.beginPath();
                sacCtx.fillStyle = 'rgba(79, 70, 229, 0.5)';
                const std_dev = 0.05 + alpha * 0.4;
                animationTime += 0.005;
                const mean = w / 2 + Math.sin(animationTime) * w/3;
                sacCtx.moveTo(0, h);
                for (let x = 0; x <= w; x++) {
                    const y = Math.exp(-0.5 * Math.pow(((x - mean) / (w/4)) / std_dev, 2)) * (h - 20);
                    sacCtx.lineTo(x, h - y);
                }
                sacCtx.lineTo(w, h);
                sacCtx.closePath();
                sacCtx.fill();
                if (alpha > 0.6) explanationEl.textContent = '高 α: 策略非常平坦, 熵奖励主导, 智能体积极探索。';
                else if (alpha < 0.1) explanationEl.textContent = '低 α: 策略非常尖锐, 任务奖励主导, 智能体积极利用。';
                else explanationEl.textContent = 'α 适中: 在探索与利用之间取得良好平衡。';
                window.activeAnimationFrames.sac = requestAnimationFrame(drawSac);
            }
            drawSac();
        }
        function initQuiz() {
            const quizContainer = document.getElementById('quiz-container');
            if(!quizContainer) return;
            const quizData = [
                {
                    question: "哪种算法是 On-Policy (同策略) 的？",
                    answers: ["DQN", "SAC", "PPO", "DDPG"],
                    correct: "PPO"
                },
                {
                    question: "DQN 使用哪项关键技术来打破数据相关性？",
                    answers: ["目标网络", "经验回放", "优势函数", "熵正则化"],
                    correct: "经验回放"
                },
                {
                    question: "SAC 算法的目标函数中，除了最大化奖励，还最大化什么？",
                    answers: ["策略的确定性", "价值函数", "策略的熵 (随机性)", "动作数量"],
                    correct: "策略的熵 (随机性)"
                },
                {
                    question: "PPO算法中的\"裁剪(Clipping)\"主要是为了解决什么问题?",
                    answers: ["提升探索效率", "限制策略更新步长，增加稳定性", "减少计算量", "处理连续动作空间"],
                    correct: "限制策略更新步长，增加稳定性"
                }
            ];
            quizContainer.innerHTML = `
                ${quizData.map((q, i) => `
                    <div class="mb-6 quiz-item" id="q-${i}">
                        <p class="font-bold mb-2">${i+1}. ${q.question}</p>
                        <div class="space-y-2">
                            ${q.answers.map(a => `<label class="block p-3 border border-themed rounded-lg hover:bg-themed-muted cursor-pointer transition-colors"><input type="radio" name="q${i}" value="${a}" class="mr-3 accent-accent-color">${a}</label>`).join('')}
                        </div>
                        <p class="text-sm mt-2 font-bold hidden quiz-feedback p-2 rounded-md"></p>
                    </div>
                `).join('')}
                <div class="flex items-center gap-4 mt-8">
                    <button id="submit-quiz" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-colors">提交答案</button>
                    <div id="quiz-final-score" class="font-bold text-lg"></div>
                </div>
            `;

            document.getElementById('submit-quiz').addEventListener('click', () => {
                let score = 0;
                quizData.forEach((q, i) => {
                    const selected = quizContainer.querySelector(`input[name="q${i}"]:checked`);
                    const feedback = quizContainer.querySelector(`#q-${i} .quiz-feedback`);
                    feedback.classList.remove('hidden', 'bg-green-100', 'text-green-700', 'bg-red-100', 'text-red-700');
                    if (selected) {
                        if (selected.value === q.correct) {
                            feedback.textContent = `回答正确！`;
                            feedback.classList.add('bg-green-100', 'text-green-700');
                            score++;
                        } else {
                            feedback.textContent = `回答错误。正确答案是: ${q.correct}`;
                            feedback.classList.add('bg-red-100', 'text-red-700');
                        }
                    } else {
                        feedback.textContent = '您未选择答案。';
                        feedback.classList.add('bg-red-100', 'text-red-700');
                    }
                    feedback.classList.remove('hidden');
                });
                const finalScoreEl = document.getElementById('quiz-final-score');
                finalScoreEl.textContent = `您的得分: ${score} / ${quizData.length}`;
            });
        }
        function initCmdpLab() {
            const builderPanel = document.getElementById('cmdp-builder-panel');
            if (!builderPanel) return;
            const checkboxes = builderPanel.querySelectorAll('.cmdp-checkbox');
            const controls = { air: document.getElementById('air-slider-ch7'), tilt: document.getElementById('tilt-slider-ch7'), ofa: document.getElementById('ofa-slider-ch7') };
            const valueLabels = { air: document.getElementById('air-value-ch7'), tilt: document.getElementById('tilt-value-ch7'), ofa: document.getElementById('ofa-value-ch7') };
            const visuals = { flame: document.getElementById('flame-visual-ch7'), noxFill: document.getElementById('nox-meter-fill-ch7'), coFill: document.getElementById('co-meter-fill-ch7'), tempFill: document.getElementById('temp-meter-fill-ch7'), efficiency: document.getElementById('efficiency-value-ch7') };
            
            function updateSimulation() {
                if (!controls.air || !controls.tilt || !controls.ofa) return;
                const air = parseFloat(controls.air.value), tilt = parseFloat(controls.tilt.value), ofa = parseFloat(controls.ofa.value);
                if (valueLabels.air) valueLabels.air.textContent = air.toFixed(0);
                if (valueLabels.tilt) valueLabels.tilt.textContent = tilt.toFixed(0);
                if (valueLabels.ofa) valueLabels.ofa.textContent = ofa.toFixed(0);
                let nox = 1.1 * air - 1.6 * ofa + 0.4 * Math.abs(tilt);
                let co = 140 - air + 0.5 * Math.abs(air - 80);
                let temp = 60 + (air - 75) + Math.abs(tilt);
                let efficiency = 91.5 + (1 - Math.abs(air - 85) / 50) * 1.5 + (1 - Math.abs(ofa - 35) / 40) * 1 - (co / 100);
                nox = Math.max(10, Math.min(100, nox));
                co = Math.max(5, Math.min(100, co));
                temp = Math.max(20, Math.min(100, temp));
                efficiency = Math.max(90, Math.min(94, efficiency));
                if (visuals.flame) {
                    visuals.flame.style.height = `${30 + (air / 100) * 70}%`;
                    visuals.flame.style.transform = `translateY(${tilt * -1.5}px) skewX(${tilt * -0.5}deg)`;
                }
                if (visuals.noxFill) visuals.noxFill.style.width = `${nox}%`;
                if (visuals.coFill) visuals.coFill.style.width = `${co}%`;
                if (visuals.tempFill) visuals.tempFill.style.width = `${temp}%`;
                if (visuals.efficiency) visuals.efficiency.textContent = efficiency.toFixed(2);
            }
            function updateUI() {
                const summary = { State: [], Action: [], Reward: [], Cost: [] };
                checkboxes.forEach(cb => {
                    const targetEl = document.getElementById(cb.dataset.target);
                    if (!targetEl) return;
                    targetEl.classList.toggle('hidden', !cb.checked);
                    targetEl.classList.remove('reward-highlight', 'cost-highlight');

                    if (cb.checked) {
                        const label = cb.parentElement.textContent.trim();
                        const header = cb.closest('div.space-y-2').previousElementSibling.textContent;
                        if (header.includes('状态')) summary.State.push(label);
                        else if (header.includes('动作')) summary.Action.push(label);
                        else if (header.includes('奖励')) {
                            summary.Reward.push(label);
                            targetEl.classList.add('reward-highlight');
                        }
                        else if (header.includes('成本')) {
                            summary.Cost.push(label);
                            targetEl.classList.add('cost-highlight');
                        }
                    }
                });
                const renderList = (key) => {
                    const el = document.getElementById(`summary-${key}-ch7`);
                    if(el) el.innerHTML = summary[key].length ? summary[key].map(item => `<li>${item}</li>`).join('') : '<li>未选</li>';
                }
                ['State', 'Action', 'Reward', 'Cost'].forEach(renderList);
            }
            checkboxes.forEach(cb => cb.addEventListener('change', updateUI));
            Object.values(controls).forEach(slider => { if(slider) slider.addEventListener('input', updateSimulation); });
            
            updateUI();
            updateSimulation();
        }
        function initSimRealCanvas() {
            const canvas = document.getElementById('sim-real-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('model-quality-slider');
            const valueDisp = document.getElementById('model-quality-value');
            let quality = 50;
            if (slider) slider.oninput = (e) => {
                quality = parseInt(e.target.value);
                if (valueDisp) valueDisp.textContent = quality;
            };
            let time = 0;
            const draw = () => {
                if(!document.getElementById('sim-real-canvas')) {
                    if(window.activeAnimationFrames.simReal) cancelAnimationFrame(window.activeAnimationFrames.simReal);
                    return;
                }
                const w = canvas.width, h = canvas.height;
                const isDark = document.documentElement.classList.contains('dark');
                ctx.clearRect(0, 0, w, h);
                time += 0.01;
                ctx.beginPath(); 
                ctx.strokeStyle = isDark ? '#f1f5f9' : '#1e293b'; 
                ctx.lineWidth = 3;
                for (let x = 0; x < w; x++) {
                    const y = h / 2 + Math.sin(x * 0.03 + time) * h / 6 + Math.cos(x * 0.07 + time) * h / 8;
                    x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.beginPath(); 
                ctx.strokeStyle = '#3b82f6'; 
                ctx.lineWidth = 2; 
                ctx.setLineDash([5, 5]);
                const noise_amplitude = (100 - quality) / 100 * h / 3;
                for (let x = 0; x < w; x++) {
                    const real_y = h / 2 + Math.sin(x * 0.03 + time) * h / 6 + Math.cos(x * 0.07 + time) * h / 8;
                    const sim_y = real_y + (Math.random() - 0.5) * noise_amplitude;
                    x === 0 ? ctx.moveTo(x, sim_y) : ctx.lineTo(x, sim_y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                window.activeAnimationFrames.simReal = requestAnimationFrame(draw);
            };
            draw();
        }
        function initRlTrainingLab() {
            const canvas = document.getElementById('rl-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const chartCtx = document.getElementById('rewardChart')?.getContext('2d');
            if (!chartCtx) return;
            const startBtn = document.getElementById('start-sim');

            const GRID_SIZE = 8;
            const GOAL = { x: GRID_SIZE - 1, y: GRID_SIZE - 1 };
            const TRAPS = [{x: 2,y: 2},{x: 2,y: 3},{x: 3,y: 2},{x: 5,y: 5},{x: 6,y: 5}];
            let agent, q_table, episode, totalReward, rewardHistory, rewardChart, simParams, agentEpisode, agentSteps, isEpisodeRunning;

            const sliders = { gamma: document.getElementById('gamma-slider'), lr: document.getElementById('lr-slider'), epsilon: document.getElementById('epsilon-slider-ch9') };
            const valueLabels = { gamma: document.getElementById('gamma-value'), lr: document.getElementById('lr-value'), epsilon: document.getElementById('epsilon-value-ch9') };
            
            function setupParams() {
                simParams = { gamma: parseFloat(sliders.gamma.value), lr: parseFloat(sliders.lr.value), epsilon: parseFloat(sliders.epsilon.value) };
                valueLabels.gamma.textContent = simParams.gamma.toFixed(2);
                valueLabels.lr.textContent = simParams.lr.toFixed(2);
                valueLabels.epsilon.textContent = simParams.epsilon.toFixed(2);
            }

            function resetSimulation() {
                if (window.rlSimulationIntervalId) clearInterval(window.rlSimulationIntervalId);
                if (window.rlAgentIntervalId) clearInterval(window.rlAgentIntervalId);
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                q_table = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0).map(() => [0, 0, 0, 0]));
                episode = 0;
                totalReward = 0;
                rewardHistory = [];
                isEpisodeRunning = false;
                
                setupParams();
                resetChart();
                updateCounters();
                
                startBtn.disabled = false;
                startBtn.innerHTML = '开始 / 重置训练';

                // Initial draw
                agent = {x:0, y:0};
                drawGrid();

                window.rlSimulationIntervalId = setInterval(runTrainingBatch, 50);
            }

            // This function runs in the background to train the Q-table
            function runTrainingBatch() {
                if (episode > 1000) { 
                    clearInterval(window.rlSimulationIntervalId); 
                    if (!isEpisodeRunning) {
                        startBtn.innerHTML = '开始可视化最终策略';
                        startBtn.onclick = () => runAgentVisualization(true);
                    }
                    return; 
                }

                for(let i=0; i < 10; i++) { // Run 10 episodes per batch for faster training
                    let current_agent = { x: 0, y: 0 };
                    let episodeReward = 0, done = false, steps = 0;
                    while (!done && steps < 50) {
                        const state = { x: current_agent.x, y: current_agent.y };
                        const action = chooseAction(state, simParams.epsilon);
                        const nextState = getNextState(state, action);
                        const reward = getReward(nextState);
                        const old_q = q_table[state.y][state.x][action];
                        const next_max_q = Math.max(...q_table[nextState.y][nextState.x]);
                        q_table[state.y][state.x][action] = old_q + simParams.lr * (reward + simParams.gamma * next_max_q - old_q);
                        current_agent = nextState;
                        episodeReward += reward;
                        steps++;
                        done = isTerminal(nextState);
                    }
                    episode++;
                    rewardHistory.push(episodeReward);
                }
                
                updateChart();
                updateCounters();
                drawGrid(); // Redraw grid to show updated policy arrows
            }

            // This function visualizes one agent run, step by step
            function runAgentVisualization(isFinalPolicy = false) {
                 if (isEpisodeRunning) return;
                 isEpisodeRunning = true;
                 startBtn.disabled = true;

                 agent = { x: 0, y: 0 };
                 agentSteps = 0;
                 
                 if (window.rlAgentIntervalId) clearInterval(window.rlAgentIntervalId);
                 window.rlAgentIntervalId = setInterval(() => {
                    if (isTerminal(agent) || agentSteps > 50) {
                        clearInterval(window.rlAgentIntervalId);
                        isEpisodeRunning = false;
                        startBtn.disabled = false;
                        if(isFinalPolicy) startBtn.innerHTML = '重新可视化';
                        return;
                    }

                    // For visualization, use a greedy policy (low epsilon)
                    const action = chooseAction(agent, isFinalPolicy ? 0.0 : simParams.epsilon);
                    agent = getNextState(agent, action);
                    agentSteps++;
                    drawGrid();
                 }, 100);
            }

            function chooseAction(state, currentEpsilon) {
                if (Math.random() < currentEpsilon) return Math.floor(Math.random() * 4);
                const q_vals = q_table[state.y][state.x];
                const max_q = Math.max(...q_vals);
                const best_actions = q_vals.map((q,i) => q === max_q ? i : -1).filter(i => i !== -1);
                return best_actions[Math.floor(Math.random() * best_actions.length)]; // Break ties randomly
            }

            function getNextState({x,y}, action) {
                if (action === 0) y = Math.max(0, y - 1);
                else if (action === 1) y = Math.min(GRID_SIZE - 1, y + 1);
                else if (action === 2) x = Math.max(0, x - 1);
                else if (action === 3) x = Math.min(GRID_SIZE - 1, x + 1);
                return { x, y };
            }
            function getReward(state) {
                if (state.x === GOAL.x && state.y === GOAL.y) return 100;
                if (TRAPS.some(t => t.x === state.x && t.y === state.y)) return -100;
                return -1;
            }
            function isTerminal(state) { return (state.x === GOAL.x && state.y === GOAL.y) || TRAPS.some(t => t.x === state.x && t.y === state.y); }
            
            function drawGrid() {
                const cellSize = canvas.width / GRID_SIZE;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const isDark = document.documentElement.classList.contains('dark');
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if(TRAPS.some(t => t.x === x && t.y === y)) ctx.fillStyle = isDark ? '#450a0a' : '#fee2e2';
                        else if(GOAL.x === x && GOAL.y === y) ctx.fillStyle = isDark ? '#064e3b' : '#dcfce7';
                        else ctx.fillStyle = isDark ? '#334155' : '#f1f5f9';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        if (!isTerminal({x,y})) {
                            const bestAction = chooseAction({x,y}, 0.0); // Always show greedy policy
                            ctx.fillStyle = isDark ? '#cbd5e1' : 'rgba(0, 0, 0, 0.6)';
                            ctx.font = `${cellSize * 0.4}px sans-serif`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(['↑', '↓', '←', '→'][bestAction], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
                        }
                    }
                }
                ctx.font = `${cellSize * 0.6}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('S', cellSize / 2, cellSize / 2);
                ctx.fillText('🏆', GOAL.x * cellSize + cellSize / 2, GOAL.y * cellSize + cellSize / 2);
                TRAPS.forEach(t => ctx.fillText('☠️', t.x * cellSize + cellSize / 2, t.y * cellSize + cellSize / 2));
                
                if(agent) {
                    ctx.fillStyle = '#3b82f6';
                    ctx.beginPath();
                    ctx.arc(agent.x * cellSize + cellSize / 2, agent.y * cellSize + cellSize / 2, cellSize / 3.5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            function resetChart() {
                if (rewardChart) rewardChart.destroy();
                const isDark = document.documentElement.classList.contains('dark');
                const textColor = isDark ? '#94a3b8' : '#475569';
                const gridColor = isDark ? 'rgba(148, 163, 184, 0.2)' : 'rgba(0, 0, 0, 0.1)';
                rewardChart = new Chart(chartCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: '最近50回合平均奖励', data: [], borderColor: '#16a34a', tension: 0.2, pointRadius: 0, fill: true, backgroundColor: 'rgba(22, 163, 74, 0.1)' }] },
                    options: { responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { title: { display: true, text: '奖励', color: textColor }, grid: { color: gridColor }, ticks: { color: textColor } } }, plugins: { legend: { display: false } } }
                });
            }
            function updateChart() {
                if (!rewardChart || episode % 20 !== 0) return; // Update chart less frequently
                const recentRewards = rewardHistory.slice(-50);
                totalReward = recentRewards.reduce((a, b) => a + b, 0) / recentRewards.length;
                rewardChart.data.labels.push(episode);
                rewardChart.data.datasets[0].data.push(totalReward);
                if (rewardChart.data.labels.length > 50) {
                    rewardChart.data.labels.shift();
                    rewardChart.data.datasets[0].data.shift();
                }
                rewardChart.update('none');
            }
            function updateCounters() {
                document.getElementById('episode-counter').textContent = episode;
                document.getElementById('total-reward').textContent = totalReward.toFixed(2);
            }
            startBtn.addEventListener('click', resetSimulation);
            Object.values(sliders).forEach(slider => slider.addEventListener('input', setupParams));
            resetSimulation();
        }
        function selectStep(step) {
            const contentEl = document.getElementById('step-content');
            if (!contentEl) return;
            const content = {
                1: { title: "阶段一：建议模式 (Advisory Mode)", description: 'RL智能体以"影子模式"运行，实时接收电厂数据并计算最优动作。但这些动作并<strong>不</strong>直接执行，而是作为操作建议显示在操作员站的界面上，由经验丰富的人工操作员确认后执行。', goals: ["在零风险下验证AI策略的长期性能。", "让操作员逐步熟悉和信任AI的决策逻辑。", "收集对比数据，量化AI相比纯人工操作的具体提升。"], risk_mitigation: "操作员拥有100%的最终控制权，AI无任何物理执行能力，实现绝对安全。" },
                2: { title: "阶段二：监督控制 (Supervisory Control)", description: 'AI的输出不再是直接的阀门动作，而是调整DCS中现有PID控制回路的<strong>设定值</strong>。例如，AI决定将"总风量PID"的目标值从50%调整到55%。', goals: ["在不改变底层可靠控制结构的前提下，实现更高层级的优化。", "利用现有DCS系统的稳定性和安全联锁作为底层安全网。", "在真实的闭环反馈下对模型进行在线微调。"], risk_mitigation: "智能体的作用范围被限制在高层设定值，底层的快速调节和安全保护仍由久经考验的PID系统完成，极大降低了风险。" },
                3: { title: "阶段三：直接控制 (Direct Control)", description: 'AI获得对执行机构的直接控制权。但其输出的所有指令在发送给DCS之前，必须强制通过一个最终的、硬编码的<strong>安全层 (Safety Layer)</strong>。', goals: ["实现完全的自主优化，对工况变化做出最快速、最直接的响应。", "最大化RL策略的性能。"], risk_mitigation: '"安全层"是一个非AI的、基于简单规则的程序。它会检查AI的每一个指令，并立即否决任何可能违反硬性安全约束的动作。这是对抗AI不可预见行为的最后一道防线。' }
            };
            for (let i = 1; i <= 3; i++) document.getElementById(`step${i}`)?.classList.toggle('active', i === step);
            const selectedContent = content[step];
            if (selectedContent) {
                contentEl.innerHTML = `<h3 class="text-xl font-bold mb-4">${selectedContent.title}</h3><p class="text-themed-secondary mb-4">${selectedContent.description}</p><h4 class="font-bold text-lg mb-2">主要目标:</h4><ul class="list-disc list-inside space-y-1 text-themed-secondary mb-4">${selectedContent.goals.map(g => `<li>${g}</li>`).join('')}</ul><h4 class="font-bold text-lg mb-2">风险控制:</h4><p class="p-3 bg-green-500/10 border border-green-500/20 text-green-700 dark:text-green-300 rounded-lg">${selectedContent.risk_mitigation}</p>`;
            }
        }
        function renderBoilerDiagram() {
            const container = document.getElementById('boiler-diagram-container');
            if (!container) return;
            container.innerHTML = `<svg viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg"><style>.txt{font-size:8px; font-family: 'Noto Sans SC', sans-serif; text-anchor: middle; fill: var(--text-secondary);} .line{stroke: var(--text-secondary); fill: none;} .arr{marker-end: url(#arrow); stroke-width: 0.8; stroke: var(--text-secondary); fill: none;}</style><defs><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="var(--text-secondary)"/></marker></defs><rect x="100" y="20" width="100" height="160" fill="var(--bg-muted)" stroke="var(--border-color)" stroke-width="1.5"/><text x="150" y="15" class="txt">锅炉</text><path d="M120,20 v-10 h60 v10" class="line" stroke-width="1.5"/><path d="M145,10 v-5 h10 v5" class="line" stroke-width="1.5"/><text x="150" y="7" class="txt" fill="#c2410c">过热蒸汽</text><rect x="110" y="100" width="80" height="40" fill="#fef9c3" stroke="#facc15" /><text x="150" y="125" class="txt">燃烧区</text><path d="M100,140 h-20 v-10 h20" class="arr" /><text x="65" y="135" class="txt">燃料+空气</text><path d="M200,160 h20 v-10 h-20" class="arr" /><text x="225" y="155" class="txt">灰渣</text><rect x="230" y="60" width="50" height="80" fill="#dbeafe" stroke="#60a5fa" stroke-width="1"/><text x="255" y="55" class="txt">汽轮机</text><path d="M150,25 h80 v40" class="arr" /><rect x="230" y="150" width="50" height="30" fill="#e0f2fe" stroke="#38bdf8" stroke-width="1"/><text x="255" y="145" class="txt">冷凝器</text><path d="M255,140 v-35" class="arr" /><rect x="40" y="160" width="50" height="20" fill="#dcfce7" stroke="#4ade80" stroke-width="1"/><text x="65" y="155" class="txt">给水泵</text><path d="M255,180 h-190 v-15" class="arr" /><path d="M40,170 h-10 v-20 h80" class="arr" /></svg>`;
        }
        function renderRankineDiagram() {
            const container = document.getElementById('rankine-diagram-container');
            if (!container) return;
            container.innerHTML = `<svg viewBox="0 0 200 150" xmlns="http://www.w3.org/2000/svg"><style>.txt{font-size:7px; font-family: 'Noto Sans SC', sans-serif; fill: var(--text-primary);} .lbl{font-size:6px; fill: var(--text-secondary);} .line{stroke-width:1; stroke:var(--text-secondary); fill:none;} .cycle{stroke-width:1.5; stroke:#ef4444; fill:none; marker-end: url(#arrow-red);}</style><defs><marker id="arrow-red" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="3" markerHeight="3" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#ef4444"/></marker></defs><path d="M20,140 L20,10 L180,10" class="line" /><text x="15" y="15" class="txt" text-anchor="end">T</text><text x="180" y="15" class="txt" text-anchor="end">s</text><path d="M40,120 C 80,120 80,40 120,40" class="line" /><text x="80" y="30" class="lbl">饱和蒸汽线</text><path d="M40,120 C 30,80 30,40 40,30" class="line" /><text x="35" y="25" class="lbl">饱和液体线</text><path d="M45,115 L45,80" class="cycle"/><text x="38" y="100" class="txt">1→2</text><text x="52" y="100" class="lbl">(泵)</text><path d="M45,80 C60,78 140,75 160,45" class="cycle"/><text x="90" y="65" class="lbl">(锅炉)</text><path d="M160,45 L170,105" class="cycle"/><text x="158" y="40" class="txt">2→3</text><text x="175" y="70" class="lbl">(汽轮机)</text><path d="M170,105 L45,115" class="cycle"/><text x="173" y="108" class="txt">3→4</text><text x="110" y="120" class="lbl">(冷凝器)</text></svg>`;
        }
        function renderRlTaxonomy() {
            const container = document.getElementById('rl-taxonomy-container');
            if (!container) return;
            container.innerHTML = `<svg viewBox="0 0 250 150" xmlns="http://www.w3.org/2000/svg"><style>.box{fill:var(--bg-secondary); stroke:var(--accent-color); rx:3;} .txt{font-size:8px; font-family: 'Noto Sans SC', sans-serif; text-anchor:middle; fill: var(--text-primary);} .line{stroke:var(--text-secondary); stroke-width:0.5;}</style><rect x="85" y="5" width="80" height="15" class="box" /><text x="125" y="14" class="txt">强化学习</text><line x1="125" y1="20" x2="125" y2="30" class="line" /><line x1="60" y1="30" x2="190" y2="30" class="line" /><line x1="60" y1="30" x2="60" y2="40" class="line" /><line x1="190" y1="30" x2="190" y2="40" class="line" /><rect x="20" y="40" width="80" height="15" class="box" /><text x="60" y="49" class="txt">基于模型</text><rect x="150" y="40" width="80" height="15" class="box" /><text x="190" y="49" class="txt">无模型</text><line x1="190" y1="55" x2="190" y2="65" class="line" /><line x1="155" y1="65" x2="225" y2="65" class="line" /><line x1="155" y1="65" x2="155" y2="75" class="line" /><line x1="225" y1="65" x2="225" y2="75" class="line" /><rect x="115" y="75" width="80" height="15" class="box" /><text x="155" y="84" class="txt">基于策略</text><rect x="185" y="75" width="80" height="15" class="box" /><text x="225" y="84" class="txt">基于价值</text><line x1="155" y1="90" x2="155" y2="100" class="line" /><rect x="115" y="100" width="80" height="15" style="fill:#dcfce7; stroke:#4ade80;" /><text x="155" y="109" class="txt">PPO</text><line x1="225" y1="90" x2="225" y2="100" class="line" /><rect x="185" y="100" width="80" height="15" style="fill:#fef9c3; stroke:#facc15;" /><text x="225" y="109" class="txt">DQN</text><path d="M155,90 C175,95 205,95 225,90" fill="none" class="line"/><line x1="190" y1="92.5" x2="190" y2="120" class="line"/><text x="190" y="108" class="txt">演员-评论家</text><rect x="150" y="120" width="80" height="15" style="fill:#fbcfe8; stroke:#f472b6;" /><text x="190" y="129" class="txt">SAC / DDPG</text></svg>`;
        }
        function renderAcDiagram(container) {
            if (!container) return;
            container.innerHTML = `<svg id="ac-viz-svg" viewBox="0 0 400 300" class="w-full max-w-lg"><defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="5" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#9ca3af" /></marker><marker id="arrowhead-h" markerWidth="10" markerHeight="7" refX="5" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#f97316" /></marker></defs><style>.ac-node rect { transition: all 0.3s ease; transform-origin: center; } .ac-node.highlight rect { stroke-width:3; transform: scale(1.05); stroke: #f97316; } .ac-arrow { transition: stroke 0.3s ease; } text { fill: var(--text-primary); font-size:12px; font-family: 'Noto Sans SC', sans-serif; text-anchor: middle; }</style><g class="ac-node" id="node-state"><rect x="10" y="30" width="80" height="40" rx="5" fill="var(--bg-secondary)" stroke="var(--border-color)" stroke-width="2" /></g><text x="50" y="25">状态 S</text><path class="ac-arrow" id="arrow-to-actor" d="M95,50 C140,50 140,90 185,90" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><g class="ac-node" id="node-actor"><rect x="185" y="85" width="80" height="40" rx="20" fill="#eff6ff" stroke="#60a5fa" stroke-width="2" /></g><text x="225" y="80">演员 Actor</text><path class="ac-arrow" id="arrow-to-action" d="M225,130 Q225,150 225,170" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><g class="ac-node" id="node-action"><rect x="185" y="170" width="80" height="40" rx="5" fill="var(--bg-secondary)" stroke="var(--border-color)" stroke-width="2" /></g><text x="225" y="165">动作 A</text><path class="ac-arrow" id="arrow-to-env" d="M180,190 C140,190 140,230 105,230" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><g class="ac-node" id="node-env"><rect x="25" y="225" width="80" height="40" rx="20" fill="#fff7ed" stroke="#fb923c" stroke-width="2" /></g><text x="65" y="220">环境 Env</text><path class="ac-arrow" id="arrow-to-critic" d="M110,245 C160,245 250,245 295,245" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" /><text x="200" y="265" font-size="10">奖励 R, 新状态 S'</text><g class="ac-node" id="node-critic"><rect x="300" y="225" width="80" height="40" rx="20" fill="#f0fdf4" stroke="#4ade80" stroke-width="2" /></g><text x="340" y="220">评论家 Critic</text><path class="ac-arrow" id="arrow-critic-to-actor" d="M340,220 C340,150 270,150 265,125" stroke="#9ca3af" stroke-width="2" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5" /><g id="label-update"><text x="310" y="170" font-weight="bold" font-size="12" fill="transparent">优势 A(s,a)</text></g></svg>`;
        }
        function renderOfflineRLDiagram() {
            const container = document.getElementById('offline-rl-diagram');
            if (!container) return;
            container.innerHTML = `<svg viewBox="0 0 400 250" class="w-full max-w-lg"><style>.text { font-size: 12px; font-family: 'Noto Sans SC', sans-serif; fill: var(--text-primary); } .small-text { font-size: 10px; fill: var(--text-secondary); }</style><defs><marker id="arrow-dark" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="var(--text-secondary)"/></marker></defs><ellipse cx="200" cy="125" rx="120" ry="60" fill="rgba(79, 70, 229, 0.1)" stroke="rgba(79, 70, 229, 0.3)" stroke-dasharray="5,5"/><text x="200" y="125" text-anchor="middle" class="text">数据集 D (行为策略 $\\pi_\\beta$ 的轨迹)</text><circle cx="150" cy="110" r="5" fill="#22c55e"/><text x="150" y="100" text-anchor="middle" class="small-text">数据支持的好动作</text><circle cx="250" cy="140" r="5" fill="#ef4444"/><text x="250" y="160" text-anchor="middle" class="small-text">数据支持的坏动作</text><circle cx="350" cy="80" r="5" fill="#f97316"/><path d="M345,85 L300,110" stroke="#f97316" stroke-width="1.5" marker-end="url(#arrow-dark)"/><text x="355" y="75" text-anchor="start" class="small-text" fill="#f97316">分布外(OOD)动作</text><text x="355" y="90" text-anchor="start" class="small-text" fill="#f97316">Q值估计不准，可能被高估</text><ellipse cx="180" cy="115" rx="50" ry="25" fill="none" stroke="#16a34a" stroke-width="2"/><text x="180" y="150" text-anchor="middle" class="text" fill="#16a34a">保守策略 $\\pi_\\theta$</text><text x="180" y="165" text-anchor="middle" class="small-text" fill="#16a34a">(被约束在数据分布内)</text></svg>`;
        }
    </script>
</body>
</html>
